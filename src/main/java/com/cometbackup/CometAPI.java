
// AUTOGENERATED, DO NOT EDIT

package com.cometbackup;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.type.MapType;
import com.fasterxml.jackson.databind.type.TypeFactory;

/**
 * Comet API
 * @version JDK 11
 */
public class CometAPI {

	private final String serverURL;
	private final String username;
	private final String password;
	static private ObjectMapper objectMapper;

	public CometAPI(String serverURL, String username, String password){
		this.serverURL = serverURL;
		this.username = username;
		this.password = password;
	}

	/**
	* request: Makes an Http request to the Comet Server.
	* @param contentType HTTP content type 
	* @param method HTTP method
	* @param path the path to use
	* @param data form data to send
	* @return A CompletableFuture which returns the response from the server 
	*/
	public CompletableFuture<HttpResponse<String>> request(String contentType, String method, String path, Map<String, String> data) {
		URI uri = URI.create(serverURL + (path.startsWith("/") ? "" : "/") + path);
		data = data != null ? data : new HashMap<>();

		var requestBuilder = HttpRequest.newBuilder()
				.uri(uri)
				.method(method, HttpRequest.BodyPublishers.noBody());

		switch (contentType) {
			case "application/x-www-form-urlencoded":
				data.put("AuthType", "Password");
				data.put("Username", username);
				data.put("Password", password);

				String formData = data.entrySet().stream()
						.map(entry -> entry.getKey() + "=" + entry.getValue())
						.reduce((param1, param2) -> param1 + "&" + param2)
						.orElse("");
				requestBuilder.header("Content-Type", contentType)
						.POST(HttpRequest.BodyPublishers.ofString(formData, StandardCharsets.UTF_8));
				break;

			case "multipart/form-data":
				byte[] multipartBytes = createMultipartFormData(data);
				requestBuilder.header("X-Comet-Admin-AuthType", "Password")
						.header("X-Comet-Admin-Username", username)
						.header("X-Comet-Admin-Password", password)
						.header("Content-Type", contentType)
						.POST(HttpRequest.BodyPublishers.ofByteArray(multipartBytes));
				break;

			default:
				throw new IllegalArgumentException("Unexpected content type: " + contentType);
		}

		HttpRequest request = requestBuilder.build();
		return HttpClient.newHttpClient().sendAsync(request, HttpResponse.BodyHandlers.ofString());
	}

	private byte[] createMultipartFormData(Map<String, String> data) {
		try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
			String boundary = "Boundary-" + System.currentTimeMillis();
			String charset = StandardCharsets.UTF_8.name();

			for (Map.Entry<String, String> entry : data.entrySet()) {
				String field = entry.getKey();
				String value = entry.getValue();

				outputStream.write(("--" + boundary + "\r\n").getBytes(charset));
				outputStream.write(("Content-Disposition: form-data; name=\"" + field + "\"\r\n").getBytes(charset));
				outputStream.write(("Content-Type: text/plain; charset=" + charset + "\r\n").getBytes(charset));
				outputStream.write(("\r\n" + value + "\r\n").getBytes(charset));
			}

			outputStream.write(("--" + boundary + "--\r\n").getBytes(charset));
			return outputStream.toByteArray();
		} catch (IOException e) {
			throw new RuntimeException("Error creating multipart/form-data", e);
		}
	}

	/**
	 * Get a cached, lazily constructed instance of the Jackson ObjectMapper class
	 * @return ObjectMapper singleton
	 */
	public static ObjectMapper getObjectMapper(){
		if(objectMapper == null){
			objectMapper = new ObjectMapper();
		}
		return objectMapper;
	}

	//
	// DEFAULT CLIENT METHODS
	//

	/**
	* AdminAccountPropertiesAsync: Retrieve properties about the current admin account
	* Some key parameters are obscured, but the obscured values are safely recognised by the corresponding
	* AdminAccountSetProperties API.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return CompletableFuture yielding an AdminAccountPropertiesResponse
	*/
	public CompletableFuture<AdminAccountPropertiesResponse> AdminAccountPropertiesAsync()  {
		var resultFuture = new CompletableFuture<AdminAccountPropertiesResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/properties", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, AdminAccountPropertiesResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountProperties: Retrieve properties about the current admin account
	* Some key parameters are obscured, but the obscured values are safely recognised by the corresponding
	* AdminAccountSetProperties API.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return an AdminAccountPropertiesResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public AdminAccountPropertiesResponse AdminAccountProperties() throws ExecutionException, InterruptedException{
		return AdminAccountPropertiesAsync().get();
	}

	/**
	* AdminAccountRegenerateTotpAsync: Generate a new TOTP secret
	* The secret is returned as a `data-uri` image of a QR code. The new secret is immediately applied to the current admin
	* account.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return CompletableFuture yielding a TotpRegeneratedResponse
	*/
	public CompletableFuture<TotpRegeneratedResponse> AdminAccountRegenerateTotpAsync()  {
		var resultFuture = new CompletableFuture<TotpRegeneratedResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/regenerate-totp", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, TotpRegeneratedResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountRegenerateTotp: Generate a new TOTP secret
	* The secret is returned as a `data-uri` image of a QR code. The new secret is immediately applied to the current admin
	* account.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return a TotpRegeneratedResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public TotpRegeneratedResponse AdminAccountRegenerateTotp() throws ExecutionException, InterruptedException{
		return AdminAccountRegenerateTotpAsync().get();
	}

	/**
	* AdminAccountSessionRevokeAsync: Revoke a session key (log out)
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAccountSessionRevokeAsync()  {
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/session-revoke", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountSessionRevoke: Revoke a session key (log out)
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminAccountSessionRevoke() throws ExecutionException, InterruptedException{
		return AdminAccountSessionRevokeAsync().get();
	}

	/**
	* AdminAccountSessionStartAsync: Generate a session key (log in)
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SelfAddress (Optional) External URL of this server
	* @return CompletableFuture yielding a SessionKeyRegeneratedResponse
	*/
	public CompletableFuture<SessionKeyRegeneratedResponse> AdminAccountSessionStartAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<SessionKeyRegeneratedResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/session-start", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, SessionKeyRegeneratedResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountSessionStart: Generate a session key (log in)
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SelfAddress (Optional) External URL of this server
	* @return a SessionKeyRegeneratedResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public SessionKeyRegeneratedResponse AdminAccountSessionStart(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminAccountSessionStartAsync(SelfAddress).get();
	}

	/**
	* AdminAccountSessionStartAsUserAsync: Generate a session key for an end-user (log in as end-user)
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param TargetUser Target account username
	* @return CompletableFuture yielding a SessionKeyRegeneratedResponse
	*/
	public CompletableFuture<SessionKeyRegeneratedResponse> AdminAccountSessionStartAsUserAsync(String TargetUser)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		var resultFuture = new CompletableFuture<SessionKeyRegeneratedResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/session-start-as-user", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, SessionKeyRegeneratedResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountSessionStartAsUser: Generate a session key for an end-user (log in as end-user)
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param TargetUser Target account username
	* @return a SessionKeyRegeneratedResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public SessionKeyRegeneratedResponse AdminAccountSessionStartAsUser(String TargetUser) throws ExecutionException, InterruptedException{
		return AdminAccountSessionStartAsUserAsync(TargetUser).get();
	}

	/**
	* AdminAccountSessionUpgradeAsync: Upgrade a session key which is pending an MFA upgrade to a full session key
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SessionKey The session key to upgrade
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAccountSessionUpgradeAsync(String SessionKey)  {
		var data = new HashMap<String,String>();

		data.put("SessionKey", SessionKey);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/session-upgrade", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountSessionUpgrade: Upgrade a session key which is pending an MFA upgrade to a full session key
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SessionKey The session key to upgrade
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminAccountSessionUpgrade(String SessionKey) throws ExecutionException, InterruptedException{
		return AdminAccountSessionUpgradeAsync(SessionKey).get();
	}

	/**
	* AdminAccountSetPropertiesAsync: Update settings for your own admin account
	* Updating your account password requires you to supply your current password.
	* To set a new plaintext password, use a password format of 0 (PASSWORD_FORMAT_PLAINTEXT).
	* This API does not currently allow you to modify your TOTP secret or IP whitelist.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Security Updated account properties
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAccountSetPropertiesAsync(AdminSecurityOptions Security) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Security", CometAPI.getObjectMapper().writeValueAsString(Security));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/set-properties", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountSetProperties: Update settings for your own admin account
	* Updating your account password requires you to supply your current password.
	* To set a new plaintext password, use a password format of 0 (PASSWORD_FORMAT_PLAINTEXT).
	* This API does not currently allow you to modify your TOTP secret or IP whitelist.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Security Updated account properties
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminAccountSetProperties(AdminSecurityOptions Security) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminAccountSetPropertiesAsync(Security).get();
	}

	/**
	* AdminAccountU2fRequestRegistrationChallengeAsync: Register a new FIDO U2F token
	* Browser support for U2F is ending in February 2022. WebAuthn is backwards
	* compatible with U2F keys, and Comet will automatically migrate existing U2F keys
	* to allow their use with the WebAuthn endpoints.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SelfAddress External URL of this server, used as U2F AppID and Facet
	* @return CompletableFuture yielding an U2FRegistrationChallengeResponse
	*/
	public CompletableFuture<U2FRegistrationChallengeResponse> AdminAccountU2fRequestRegistrationChallengeAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", SelfAddress);
		var resultFuture = new CompletableFuture<U2FRegistrationChallengeResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/u2f/request-registration-challenge", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, U2FRegistrationChallengeResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountU2fRequestRegistrationChallenge: Register a new FIDO U2F token
	* Browser support for U2F is ending in February 2022. WebAuthn is backwards
	* compatible with U2F keys, and Comet will automatically migrate existing U2F keys
	* to allow their use with the WebAuthn endpoints.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SelfAddress External URL of this server, used as U2F AppID and Facet
	* @return an U2FRegistrationChallengeResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public U2FRegistrationChallengeResponse AdminAccountU2fRequestRegistrationChallenge(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminAccountU2fRequestRegistrationChallengeAsync(SelfAddress).get();
	}

	/**
	* AdminAccountU2fSubmitChallengeResponseAsync: Register a new FIDO U2F token
	* Browser support for U2F is ending in February 2022. WebAuthn is backwards
	* compatible with U2F keys, and Comet will automatically migrate existing U2F keys
	* to allow their use with the WebAuthn endpoints.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param U2FChallengeID Associated value from AdminAccountU2fRequestRegistrationChallenge API
	* @param U2FClientData U2F response data supplied by hardware token
	* @param U2FRegistrationData U2F response data supplied by hardware token
	* @param U2FVersion U2F response data supplied by hardware token
	* @param Description (Optional) Description of the token
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAccountU2fSubmitChallengeResponseAsync(String U2FChallengeID, String U2FClientData, String U2FRegistrationData, String U2FVersion, String Description)  {
		var data = new HashMap<String,String>();

		data.put("U2FChallengeID", U2FChallengeID);
		data.put("U2FClientData", U2FClientData);
		data.put("U2FRegistrationData", U2FRegistrationData);
		data.put("U2FVersion", U2FVersion);
		if (Description != null) data.put("Description",  Description);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/u2f/submit-challenge-response", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountU2fSubmitChallengeResponse: Register a new FIDO U2F token
	* Browser support for U2F is ending in February 2022. WebAuthn is backwards
	* compatible with U2F keys, and Comet will automatically migrate existing U2F keys
	* to allow their use with the WebAuthn endpoints.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param U2FChallengeID Associated value from AdminAccountU2fRequestRegistrationChallenge API
	* @param U2FClientData U2F response data supplied by hardware token
	* @param U2FRegistrationData U2F response data supplied by hardware token
	* @param U2FVersion U2F response data supplied by hardware token
	* @param Description (Optional) Description of the token
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminAccountU2fSubmitChallengeResponse(String U2FChallengeID, String U2FClientData, String U2FRegistrationData, String U2FVersion, String Description) throws ExecutionException, InterruptedException{
		return AdminAccountU2fSubmitChallengeResponseAsync(U2FChallengeID, U2FClientData, U2FRegistrationData, U2FVersion, Description).get();
	}

	/**
	* AdminAccountValidateTotpAsync: Validate the TOTP code before turning 2fa(TOTP) on
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param TOTPCode Six-digit code after scanning barcode image
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAccountValidateTotpAsync(String TOTPCode)  {
		var data = new HashMap<String,String>();

		data.put("TOTPCode", TOTPCode);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/validate-totp", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountValidateTotp: Validate the TOTP code before turning 2fa(TOTP) on
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param TOTPCode Six-digit code after scanning barcode image
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminAccountValidateTotp(String TOTPCode) throws ExecutionException, InterruptedException{
		return AdminAccountValidateTotpAsync(TOTPCode).get();
	}

	/**
	* AdminAccountWebauthnRequestRegistrationChallengeAsync: Register a new FIDO2 WebAuthn token
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SelfAddress External URL of this server, used as WebAuthn ID
	* @return CompletableFuture yielding a WebAuthnRegistrationChallengeResponse
	*/
	public CompletableFuture<WebAuthnRegistrationChallengeResponse> AdminAccountWebauthnRequestRegistrationChallengeAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", SelfAddress);
		var resultFuture = new CompletableFuture<WebAuthnRegistrationChallengeResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/webauthn/request-registration-challenge", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, WebAuthnRegistrationChallengeResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountWebauthnRequestRegistrationChallenge: Register a new FIDO2 WebAuthn token
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SelfAddress External URL of this server, used as WebAuthn ID
	* @return a WebAuthnRegistrationChallengeResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public WebAuthnRegistrationChallengeResponse AdminAccountWebauthnRequestRegistrationChallenge(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminAccountWebauthnRequestRegistrationChallengeAsync(SelfAddress).get();
	}

	/**
	* AdminAccountWebauthnSubmitChallengeResponseAsync: Register a new FIDO2 WebAuthn token
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SelfAddress External URL of this server, used as WebAuthn ID
	* @param ChallengeID Associated value from AdminAccountWebAuthnRequestRegistrationChallenge API
	* @param Credential JSON-encoded credential
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAccountWebauthnSubmitChallengeResponseAsync(String SelfAddress, String ChallengeID, String Credential)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", SelfAddress);
		data.put("ChallengeID", ChallengeID);
		data.put("Credential", Credential);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/account/webauthn/submit-challenge-response", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAccountWebauthnSubmitChallengeResponse: Register a new FIDO2 WebAuthn token
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SelfAddress External URL of this server, used as WebAuthn ID
	* @param ChallengeID Associated value from AdminAccountWebAuthnRequestRegistrationChallenge API
	* @param Credential JSON-encoded credential
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminAccountWebauthnSubmitChallengeResponse(String SelfAddress, String ChallengeID, String Credential) throws ExecutionException, InterruptedException{
		return AdminAccountWebauthnSubmitChallengeResponseAsync(SelfAddress, ChallengeID, Credential).get();
	}

	/**
	* AdminAddFirstAdminUserAsync: Add first admin user account on new server
	* @param TargetUser the username for this new admin
	* @param TargetPassword the password for this new admin user
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAddFirstAdminUserAsync(String TargetUser, String TargetPassword)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("TargetPassword", TargetPassword);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/add-first-admin-user", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAddFirstAdminUser: Add first admin user account on new server
	* @param TargetUser the username for this new admin
	* @param TargetPassword the password for this new admin user
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminAddFirstAdminUser(String TargetUser, String TargetPassword) throws ExecutionException, InterruptedException{
		return AdminAddFirstAdminUserAsync(TargetUser, TargetPassword).get();
	}

	/**
	* AdminAddUserAsync: Add a new user account
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser New account username
	* @param TargetPassword New account password
	* @param StoreRecoveryCode (Optional) If set to 1, store and keep a password recovery code for the generated user
	* (&gt;= 18.3.9)
	* @param RequirePasswordChange (Optional) If set to 1, require to reset password at the first login for the generated
	* user (&gt;= 20.3.4)
	* @param TargetOrganization (Optional) If present, create the user account on behalf of another organization. Only
	* allowed for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAddUserAsync(String TargetUser, String TargetPassword, Integer StoreRecoveryCode, Integer RequirePasswordChange, String TargetOrganization) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("TargetPassword", TargetPassword);
		if (StoreRecoveryCode != null) data.put("StoreRecoveryCode", CometAPI.getObjectMapper().writeValueAsString(StoreRecoveryCode));
		if (RequirePasswordChange != null) data.put("RequirePasswordChange", CometAPI.getObjectMapper().writeValueAsString(RequirePasswordChange));
		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/add-user", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAddUser: Add a new user account
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser New account username
	* @param TargetPassword New account password
	* @param StoreRecoveryCode (Optional) If set to 1, store and keep a password recovery code for the generated user
	* (&gt;= 18.3.9)
	* @param RequirePasswordChange (Optional) If set to 1, require to reset password at the first login for the generated
	* user (&gt;= 20.3.4)
	* @param TargetOrganization (Optional) If present, create the user account on behalf of another organization. Only
	* allowed for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminAddUser(String TargetUser, String TargetPassword, Integer StoreRecoveryCode, Integer RequirePasswordChange, String TargetOrganization) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminAddUserAsync(TargetUser, TargetPassword, StoreRecoveryCode, RequirePasswordChange, TargetOrganization).get();
	}

	/**
	* AdminAddUserFromProfileAsync: Add a new user account (with all information)
	* This allows you to create a new account and set all its properties at once (e.g. during account replication).
	* Developers creating a signup form may find it simpler to use the AdminAddUser and AdminGetUserProfile /
	* AdminSetUserProfile APIs separately.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser New account username
	* @param ProfileData New account profile
	* @param TargetOrganization (Optional) If present, create the user account on behalf of another organization. Only
	* allowed for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAddUserFromProfileAsync(String TargetUser, UserProfileConfig ProfileData, String TargetOrganization) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("ProfileData", CometAPI.getObjectMapper().writeValueAsString(ProfileData));
		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/add-user-from-profile", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAddUserFromProfile: Add a new user account (with all information)
	* This allows you to create a new account and set all its properties at once (e.g. during account replication).
	* Developers creating a signup form may find it simpler to use the AdminAddUser and AdminGetUserProfile /
	* AdminSetUserProfile APIs separately.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser New account username
	* @param ProfileData New account profile
	* @param TargetOrganization (Optional) If present, create the user account on behalf of another organization. Only
	* allowed for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminAddUserFromProfile(String TargetUser, UserProfileConfig ProfileData, String TargetOrganization) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminAddUserFromProfileAsync(TargetUser, ProfileData, TargetOrganization).get();
	}

	/**
	* AdminAdminUserDeleteAsync: Delete an administrator
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param TargetUser the username of the admin to be deleted
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAdminUserDeleteAsync(String TargetUser)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/admin-user/delete", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAdminUserDelete: Delete an administrator
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param TargetUser the username of the admin to be deleted
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminAdminUserDelete(String TargetUser) throws ExecutionException, InterruptedException{
		return AdminAdminUserDeleteAsync(TargetUser).get();
	}

	/**
	* AdminAdminUserListAsync: List administrators
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return CompletableFuture yielding an AllowedAdminUser[]
	*/
	public CompletableFuture<AllowedAdminUser[]> AdminAdminUserListAsync()  {
		var resultFuture = new CompletableFuture<AllowedAdminUser[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/admin-user/list", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, AllowedAdminUser[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAdminUserList: List administrators
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return an AllowedAdminUser[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public AllowedAdminUser[] AdminAdminUserList() throws ExecutionException, InterruptedException{
		return AdminAdminUserListAsync().get();
	}

	/**
	* AdminAdminUserNewAsync: Add a new administrator
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param TargetUser the username for this new admin
	* @param TargetPassword the password for this new admin user
	* @param TargetOrgID (Optional) provide the organization ID for this user, it will default to the org of the
	* authenticating user otherwise
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminAdminUserNewAsync(String TargetUser, String TargetPassword, String TargetOrgID)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("TargetPassword", TargetPassword);
		if (TargetOrgID != null) data.put("TargetOrgID",  TargetOrgID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/admin-user/new", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminAdminUserNew: Add a new administrator
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param TargetUser the username for this new admin
	* @param TargetPassword the password for this new admin user
	* @param TargetOrgID (Optional) provide the organization ID for this user, it will default to the org of the
	* authenticating user otherwise
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminAdminUserNew(String TargetUser, String TargetPassword, String TargetOrgID) throws ExecutionException, InterruptedException{
		return AdminAdminUserNewAsync(TargetUser, TargetPassword, TargetOrgID).get();
	}

	/**
	* AdminBrandingAvailablePlatformsAsync: List available software download platforms
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a HashMap&lt;Integer,AvailableDownload&gt;
	*/
	public CompletableFuture<HashMap<Integer,AvailableDownload>> AdminBrandingAvailablePlatformsAsync()  {
		var resultFuture = new CompletableFuture<HashMap<Integer,AvailableDownload>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/available-platforms", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, Integer.class, AvailableDownload.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingAvailablePlatforms: List available software download platforms
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @return a HashMap&lt;Integer,AvailableDownload&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<Integer,AvailableDownload> AdminBrandingAvailablePlatforms() throws ExecutionException, InterruptedException{
		return AdminBrandingAvailablePlatformsAsync().get();
	}

	/**
	* AdminBrandingGenerateClientByPlatformAsync: Download software
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param Platform The selected download platform, from the AdminBrandingAvailablePlatforms API
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientByPlatformAsync(Integer Platform, String SelfAddress) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Platform", CometAPI.getObjectMapper().writeValueAsString(Platform));
		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/by-platform", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientByPlatform: Download software
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param Platform The selected download platform, from the AdminBrandingAvailablePlatforms API
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public byte[] AdminBrandingGenerateClientByPlatform(Integer Platform, String SelfAddress) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminBrandingGenerateClientByPlatformAsync(Platform, SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientLinuxDebAsync: Download software (Linux Debian Package)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientLinuxDebAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/linux-deb", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientLinuxDeb: Download software (Linux Debian Package)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientLinuxDeb(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientLinuxDebAsync(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientLinuxgenericAsync: Download software (Linux Server .run)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientLinuxgenericAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/linuxgeneric", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientLinuxgeneric: Download software (Linux Server .run)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientLinuxgeneric(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientLinuxgenericAsync(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientMacosArm64Async: Download software (macOS arm64 pkg)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientMacosArm64Async(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/macos-arm64", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientMacosArm64: Download software (macOS arm64 pkg)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientMacosArm64(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientMacosArm64Async(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientMacosX8664Async: Download software (macOS x86_64 pkg)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientMacosX8664Async(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/macos-x86_64", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientMacosX8664: Download software (macOS x86_64 pkg)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientMacosX8664(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientMacosX8664Async(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientSpkDsm6Async: Download software (Synology SPK for DSM 6)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientSpkDsm6Async(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/spk-dsm6", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientSpkDsm6: Download software (Synology SPK for DSM 6)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientSpkDsm6(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientSpkDsm6Async(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientSpkDsm7Async: Download software (Synology SPK for DSM 7)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientSpkDsm7Async(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/spk-dsm7", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientSpkDsm7: Download software (Synology SPK for DSM 7)
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientSpkDsm7(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientSpkDsm7Async(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientTestAsync: Check if a software download is available
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param Platform The selected download platform, from the AdminBrandingAvailablePlatforms API
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminBrandingGenerateClientTestAsync(Integer Platform, String SelfAddress) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Platform", CometAPI.getObjectMapper().writeValueAsString(Platform));
		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/test", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientTest: Check if a software download is available
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param Platform The selected download platform, from the AdminBrandingAvailablePlatforms API
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminBrandingGenerateClientTest(Integer Platform, String SelfAddress) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminBrandingGenerateClientTestAsync(Platform, SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientWindowsAnycpuExeAsync: Download software update (Windows AnyCPU exe)
	* The exe endpoints are not recommended for end-users, as they may not be able to provide a codesigned installer if no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientWindowsAnycpuExeAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/windows-anycpu-exe", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientWindowsAnycpuExe: Download software update (Windows AnyCPU exe)
	* The exe endpoints are not recommended for end-users, as they may not be able to provide a codesigned installer if no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientWindowsAnycpuExe(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientWindowsAnycpuExeAsync(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientWindowsAnycpuZipAsync: Download software (Windows AnyCPU zip)
	* The zip endpoints are recommended for end-users, as they may be able to provide a codesigned installer even when no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientWindowsAnycpuZipAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/windows-anycpu-zip", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientWindowsAnycpuZip: Download software (Windows AnyCPU zip)
	* The zip endpoints are recommended for end-users, as they may be able to provide a codesigned installer even when no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientWindowsAnycpuZip(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientWindowsAnycpuZipAsync(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientWindowsX8632ExeAsync: Download software update (Windows x86_32 exe)
	* The exe endpoints are not recommended for end-users, as they may not be able to provide a codesigned installer if no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientWindowsX8632ExeAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/windows-x86_32-exe", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientWindowsX8632Exe: Download software update (Windows x86_32 exe)
	* The exe endpoints are not recommended for end-users, as they may not be able to provide a codesigned installer if no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientWindowsX8632Exe(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientWindowsX8632ExeAsync(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientWindowsX8632ZipAsync: Download software (Windows x86_32 zip)
	* The zip endpoints are recommended for end-users, as they may be able to provide a codesigned installer even when no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientWindowsX8632ZipAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/windows-x86_32-zip", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientWindowsX8632Zip: Download software (Windows x86_32 zip)
	* The zip endpoints are recommended for end-users, as they may be able to provide a codesigned installer even when no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientWindowsX8632Zip(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientWindowsX8632ZipAsync(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientWindowsX8664ExeAsync: Download software update (Windows x86_64 exe)
	* The exe endpoints are not recommended for end-users, as they may not be able to provide a codesigned installer if no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientWindowsX8664ExeAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/windows-x86_64-exe", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientWindowsX8664Exe: Download software update (Windows x86_64 exe)
	* The exe endpoints are not recommended for end-users, as they may not be able to provide a codesigned installer if no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientWindowsX8664Exe(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientWindowsX8664ExeAsync(SelfAddress).get();
	}

	/**
	* AdminBrandingGenerateClientWindowsX8664ZipAsync: Download software (Windows x86_64 zip)
	* The zip endpoints are recommended for end-users, as they may be able to provide a codesigned installer even when no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminBrandingGenerateClientWindowsX8664ZipAsync(String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/branding/generate-client/windows-x86_64-zip", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBrandingGenerateClientWindowsX8664Zip: Download software (Windows x86_64 zip)
	* The zip endpoints are recommended for end-users, as they may be able to provide a codesigned installer even when no
	* custom codesigning certificate is present.
	* 
	* This API requires administrator authentication credentials, unless the server is configured to allow unauthenticated
	* software downloads.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminBrandingGenerateClientWindowsX8664Zip(String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminBrandingGenerateClientWindowsX8664ZipAsync(SelfAddress).get();
	}

	/**
	* AdminBulletinSubmitAsync: Send an email bulletin to all users
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Subject Bulletin subject line
	* @param Content Bulletin message content
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminBulletinSubmitAsync(String Subject, String Content)  {
		var data = new HashMap<String,String>();

		data.put("Subject", Subject);
		data.put("Content", Content);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/bulletin/submit", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminBulletinSubmit: Send an email bulletin to all users
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Subject Bulletin subject line
	* @param Content Bulletin message content
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminBulletinSubmit(String Subject, String Content) throws ExecutionException, InterruptedException{
		return AdminBulletinSubmitAsync(Subject, Content).get();
	}

	/**
	* AdminConstellationLastReportAsync: Get Constellation bucket usage report (cached)
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @return CompletableFuture yielding a ConstellationCheckReport
	*/
	public CompletableFuture<ConstellationCheckReport> AdminConstellationLastReportAsync()  {
		var resultFuture = new CompletableFuture<ConstellationCheckReport>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/constellation/last-report", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ConstellationCheckReport.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminConstellationLastReport: Get Constellation bucket usage report (cached)
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @return a ConstellationCheckReport
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ConstellationCheckReport AdminConstellationLastReport() throws ExecutionException, InterruptedException{
		return AdminConstellationLastReportAsync().get();
	}

	/**
	* AdminConstellationNewReportAsync: Get Constellation bucket usage report (regenerate)
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @return CompletableFuture yielding a ConstellationCheckReport
	*/
	public CompletableFuture<ConstellationCheckReport> AdminConstellationNewReportAsync()  {
		var resultFuture = new CompletableFuture<ConstellationCheckReport>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/constellation/new-report", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ConstellationCheckReport.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminConstellationNewReport: Get Constellation bucket usage report (regenerate)
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @return a ConstellationCheckReport
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ConstellationCheckReport AdminConstellationNewReport() throws ExecutionException, InterruptedException{
		return AdminConstellationNewReportAsync().get();
	}

	/**
	* AdminConstellationPruneNowAsync: Prune unused buckets
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* This API requires the Constellation Role to be enabled.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminConstellationPruneNowAsync()  {
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/constellation/prune-now", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminConstellationPruneNow: Prune unused buckets
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* This API requires the Constellation Role to be enabled.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminConstellationPruneNow() throws ExecutionException, InterruptedException{
		return AdminConstellationPruneNowAsync().get();
	}

	/**
	* AdminConstellationStatusAsync: Get Constellation status
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @return CompletableFuture yielding a ConstellationStatusAPIResponse
	*/
	public CompletableFuture<ConstellationStatusAPIResponse> AdminConstellationStatusAsync()  {
		var resultFuture = new CompletableFuture<ConstellationStatusAPIResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/constellation/status", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ConstellationStatusAPIResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminConstellationStatus: Get Constellation status
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @return a ConstellationStatusAPIResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ConstellationStatusAPIResponse AdminConstellationStatus() throws ExecutionException, InterruptedException{
		return AdminConstellationStatusAsync().get();
	}

	/**
	* AdminConvertStorageRoleAsync: Convert IAM Storage Role vault to its underlying S3 type
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param TargetUser The user to receive the new Storage Vault
	* @param DestinationId The id of the old storage role destination to convert
	* @return CompletableFuture yielding a RequestStorageVaultResponseMessage
	*/
	public CompletableFuture<RequestStorageVaultResponseMessage> AdminConvertStorageRoleAsync(String TargetUser, String DestinationId)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("DestinationId", DestinationId);
		var resultFuture = new CompletableFuture<RequestStorageVaultResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/convert-storage-role", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, RequestStorageVaultResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminConvertStorageRole: Convert IAM Storage Role vault to its underlying S3 type
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param TargetUser The user to receive the new Storage Vault
	* @param DestinationId The id of the old storage role destination to convert
	* @return a RequestStorageVaultResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public RequestStorageVaultResponseMessage AdminConvertStorageRole(String TargetUser, String DestinationId) throws ExecutionException, InterruptedException{
		return AdminConvertStorageRoleAsync(TargetUser, DestinationId).get();
	}

	/**
	* AdminCountJobsForCustomSearchAsync: Count jobs (for custom search)
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Query (No description available)
	* @return CompletableFuture yielding a CountJobsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CountJobsResponse> AdminCountJobsForCustomSearchAsync(SearchClause Query) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Query", CometAPI.getObjectMapper().writeValueAsString(Query));
		var resultFuture = new CompletableFuture<CountJobsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/count-jobs-for-custom-search", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CountJobsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminCountJobsForCustomSearch: Count jobs (for custom search)
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Query (No description available)
	* @return a CountJobsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CountJobsResponse AdminCountJobsForCustomSearch(SearchClause Query) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminCountJobsForCustomSearchAsync(Query).get();
	}

	/**
	* AdminCreateInstallTokenAsync: Create token for silent installation
	* Currently only supported for Windows &amp; macOS only
	* Provide the installation token to silently install the client on windows `install.exe /TOKEN=&lt;installtoken&gt;`
	* Provide the installation token to silently install the client on Mac OS `sudo launchctl setenv BACKUP_APP_TOKEN
	* &#34;installtoken&#34; &amp;&amp; sudo /usr/sbin/installer -allowUntrusted -pkg &#34;Comet Backup.pkg&#34; -target /`
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param TargetPassword Selected account password
	* @param Server (Optional) External URL of the authentication server that is different from the current server
	* @return CompletableFuture yielding an InstallTokenResponse
	*/
	public CompletableFuture<InstallTokenResponse> AdminCreateInstallTokenAsync(String TargetUser, String TargetPassword, String Server)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("TargetPassword", TargetPassword);
		if (Server != null) data.put("Server",  Server);
		var resultFuture = new CompletableFuture<InstallTokenResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/create-install-token", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, InstallTokenResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminCreateInstallToken: Create token for silent installation
	* Currently only supported for Windows &amp; macOS only
	* Provide the installation token to silently install the client on windows `install.exe /TOKEN=&lt;installtoken&gt;`
	* Provide the installation token to silently install the client on Mac OS `sudo launchctl setenv BACKUP_APP_TOKEN
	* &#34;installtoken&#34; &amp;&amp; sudo /usr/sbin/installer -allowUntrusted -pkg &#34;Comet Backup.pkg&#34; -target /`
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param TargetPassword Selected account password
	* @param Server (Optional) External URL of the authentication server that is different from the current server
	* @return an InstallTokenResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public InstallTokenResponse AdminCreateInstallToken(String TargetUser, String TargetPassword, String Server) throws ExecutionException, InterruptedException{
		return AdminCreateInstallTokenAsync(TargetUser, TargetPassword, Server).get();
	}

	/**
	* AdminDeleteUserAsync: Delete user account
	* This does not remove any storage buckets. Unused storage buckets will be cleaned up by the Constellation Role.
	* Any stored data can not be decrypted without the user profile. Misuse can cause data loss!
	* This also allows to uninstall software from active devices under the user account
	* This also removes all job history for the user account.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param UninstallConfig (Optional) Uninstall software configuration (&gt;= 20.3.5)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDeleteUserAsync(String TargetUser, UninstallConfig UninstallConfig) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		if (UninstallConfig != null) data.put("UninstallConfig", CometAPI.getObjectMapper().writeValueAsString(UninstallConfig));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/delete-user", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDeleteUser: Delete user account
	* This does not remove any storage buckets. Unused storage buckets will be cleaned up by the Constellation Role.
	* Any stored data can not be decrypted without the user profile. Misuse can cause data loss!
	* This also allows to uninstall software from active devices under the user account
	* This also removes all job history for the user account.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param UninstallConfig (Optional) Uninstall software configuration (&gt;= 20.3.5)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDeleteUser(String TargetUser, UninstallConfig UninstallConfig) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDeleteUserAsync(TargetUser, UninstallConfig).get();
	}

	/**
	* AdminDisableUserTotpAsync: Disable user account 2FA(TOTP) authentication
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDisableUserTotpAsync(String TargetUser)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/disable-user-totp", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDisableUserTotp: Disable user account 2FA(TOTP) authentication
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDisableUserTotp(String TargetUser) throws ExecutionException, InterruptedException{
		return AdminDisableUserTotpAsync(TargetUser).get();
	}

	/**
	* AdminDispatcherApplyRetentionRulesAsync: Instruct a live connected device to apply retention rules now
	* This command is understood by Comet Backup 17.6.9 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherApplyRetentionRulesAsync(String TargetID, String Destination)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/apply-retention-rules", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherApplyRetentionRules: Instruct a live connected device to apply retention rules now
	* This command is understood by Comet Backup 17.6.9 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherApplyRetentionRules(String TargetID, String Destination) throws ExecutionException, InterruptedException{
		return AdminDispatcherApplyRetentionRulesAsync(TargetID, Destination).get();
	}

	/**
	* AdminDispatcherDeepverifyStorageVaultAsync: Instruct a live connected device to deeply verify Storage Vault content
	* This command is understood by Comet Backup 18.8.2 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherDeepverifyStorageVaultAsync(String TargetID, String Destination)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/deepverify-storage-vault", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherDeepverifyStorageVault: Instruct a live connected device to deeply verify Storage Vault content
	* This command is understood by Comet Backup 18.8.2 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherDeepverifyStorageVault(String TargetID, String Destination) throws ExecutionException, InterruptedException{
		return AdminDispatcherDeepverifyStorageVaultAsync(TargetID, Destination).get();
	}

	/**
	* AdminDispatcherDeleteSnapshotAsync: Instruct a live connected device to delete a stored snapshot
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotID The backup job snapshot ID to delete
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherDeleteSnapshotAsync(String TargetID, String DestinationID, String SnapshotID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("DestinationID", DestinationID);
		data.put("SnapshotID", SnapshotID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/delete-snapshot", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherDeleteSnapshot: Instruct a live connected device to delete a stored snapshot
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotID The backup job snapshot ID to delete
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherDeleteSnapshot(String TargetID, String DestinationID, String SnapshotID) throws ExecutionException, InterruptedException{
		return AdminDispatcherDeleteSnapshotAsync(TargetID, DestinationID, SnapshotID).get();
	}

	/**
	* AdminDispatcherDeleteSnapshotsAsync: Instruct a live connected device to delete multiple stored snapshots
	* The target device must be running Comet 20.9.10 or later.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotIDs The backup job snapshot IDs to delete
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherDeleteSnapshotsAsync(String TargetID, String DestinationID, String[] SnapshotIDs) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("DestinationID", DestinationID);
		data.put("SnapshotIDs", CometAPI.getObjectMapper().writeValueAsString(SnapshotIDs));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/delete-snapshots", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherDeleteSnapshots: Instruct a live connected device to delete multiple stored snapshots
	* The target device must be running Comet 20.9.10 or later.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotIDs The backup job snapshot IDs to delete
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDispatcherDeleteSnapshots(String TargetID, String DestinationID, String[] SnapshotIDs) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherDeleteSnapshotsAsync(TargetID, DestinationID, SnapshotIDs).get();
	}

	/**
	* AdminDispatcherDropConnectionAsync: Disconnect a live connected device
	* The device will almost certainly attempt to reconnect.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherDropConnectionAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/drop-connection", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherDropConnection: Disconnect a live connected device
	* The device will almost certainly attempt to reconnect.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherDropConnection(String TargetID) throws ExecutionException, InterruptedException{
		return AdminDispatcherDropConnectionAsync(TargetID).get();
	}

	/**
	* AdminDispatcherEmailPreviewAsync: Request HTML content of an email
	* The remote device must have given consent for an MSP to browse their mail
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Snapshot where the email belongs to
	* @param Destination The Storage Vault ID
	* @param Path of the email to view
	* @return CompletableFuture yielding an EmailReportGeneratedPreview
	*/
	public CompletableFuture<EmailReportGeneratedPreview> AdminDispatcherEmailPreviewAsync(String TargetID, String Snapshot, String Destination, String Path)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Snapshot", Snapshot);
		data.put("Destination", Destination);
		data.put("Path", Path);
		var resultFuture = new CompletableFuture<EmailReportGeneratedPreview>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/email-preview", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, EmailReportGeneratedPreview.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherEmailPreview: Request HTML content of an email
	* The remote device must have given consent for an MSP to browse their mail
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Snapshot where the email belongs to
	* @param Destination The Storage Vault ID
	* @param Path of the email to view
	* @return an EmailReportGeneratedPreview
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public EmailReportGeneratedPreview AdminDispatcherEmailPreview(String TargetID, String Snapshot, String Destination, String Path) throws ExecutionException, InterruptedException{
		return AdminDispatcherEmailPreviewAsync(TargetID, Snapshot, Destination, Path).get();
	}

	/**
	* AdminDispatcherGetDefaultLoginUrlAsync: Get the default login URL for a tenant
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param OrganizationID Target organization
	* @return CompletableFuture yielding an OrganizationLoginURLResponse
	*/
	public CompletableFuture<OrganizationLoginURLResponse> AdminDispatcherGetDefaultLoginUrlAsync(String OrganizationID)  {
		var data = new HashMap<String,String>();

		data.put("OrganizationID", OrganizationID);
		var resultFuture = new CompletableFuture<OrganizationLoginURLResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/get-default-login-url", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, OrganizationLoginURLResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherGetDefaultLoginUrl: Get the default login URL for a tenant
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param OrganizationID Target organization
	* @return an OrganizationLoginURLResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public OrganizationLoginURLResponse AdminDispatcherGetDefaultLoginUrl(String OrganizationID) throws ExecutionException, InterruptedException{
		return AdminDispatcherGetDefaultLoginUrlAsync(OrganizationID).get();
	}

	/**
	* AdminDispatcherImportApplyAsync: Instruct a live connected device to import settings from an installed product
	* This command is understood by Comet Backup 17.12.0 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param ImportSourceID The selected import source, as found by the AdminDispatcherRequestImportSources API
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherImportApplyAsync(String TargetID, String ImportSourceID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("ImportSourceID", ImportSourceID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/import-apply", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherImportApply: Instruct a live connected device to import settings from an installed product
	* This command is understood by Comet Backup 17.12.0 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param ImportSourceID The selected import source, as found by the AdminDispatcherRequestImportSources API
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherImportApply(String TargetID, String ImportSourceID) throws ExecutionException, InterruptedException{
		return AdminDispatcherImportApplyAsync(TargetID, ImportSourceID).get();
	}

	/**
	* AdminDispatcherKillProcessAsync: Instruct a live connected device to disconnect
	* The device will terminate its live-connection process and will not reconnect.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherKillProcessAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/kill-process", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherKillProcess: Instruct a live connected device to disconnect
	* The device will terminate its live-connection process and will not reconnect.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherKillProcess(String TargetID) throws ExecutionException, InterruptedException{
		return AdminDispatcherKillProcessAsync(TargetID).get();
	}

	/**
	* AdminDispatcherListActiveAsync: List live connected devices
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param UserNameFilter (Optional) User name filter string
	* @return CompletableFuture yielding a HashMap&lt;String,LiveUserConnection&gt;
	*/
	public CompletableFuture<HashMap<String,LiveUserConnection>> AdminDispatcherListActiveAsync(String UserNameFilter)  {
		var data = new HashMap<String,String>();

		if (UserNameFilter != null) data.put("UserNameFilter",  UserNameFilter);
		var resultFuture = new CompletableFuture<HashMap<String,LiveUserConnection>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/list-active", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, LiveUserConnection.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherListActive: List live connected devices
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param UserNameFilter (Optional) User name filter string
	* @return a HashMap&lt;String,LiveUserConnection&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,LiveUserConnection> AdminDispatcherListActive(String UserNameFilter) throws ExecutionException, InterruptedException{
		return AdminDispatcherListActiveAsync(UserNameFilter).get();
	}

	/**
	* AdminDispatcherOffice365ListVirtualAccountsAsync: Request a list of Office365 Resources (groups, sites, teams groups
	* and users)
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return CompletableFuture yielding a BrowseOffice365ListVirtualAccountsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseOffice365ListVirtualAccountsResponse> AdminDispatcherOffice365ListVirtualAccountsAsync(String TargetID, Office365Credential Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseOffice365ListVirtualAccountsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/office365-list-virtual-accounts", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseOffice365ListVirtualAccountsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherOffice365ListVirtualAccounts: Request a list of Office365 Resources (groups, sites, teams groups and
	* users)
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return a BrowseOffice365ListVirtualAccountsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseOffice365ListVirtualAccountsResponse AdminDispatcherOffice365ListVirtualAccounts(String TargetID, Office365Credential Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherOffice365ListVirtualAccountsAsync(TargetID, Credentials).get();
	}

	/**
	* AdminDispatcherPingDestinationAsync: Test the connection to the storage bucket
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param ExtraData The destination location settings
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherPingDestinationAsync(String TargetID, DestinationLocation ExtraData) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("ExtraData", CometAPI.getObjectMapper().writeValueAsString(ExtraData));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/ping-destination", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherPingDestination: Test the connection to the storage bucket
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param ExtraData The destination location settings
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDispatcherPingDestination(String TargetID, DestinationLocation ExtraData) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherPingDestinationAsync(TargetID, ExtraData).get();
	}

	/**
	* AdminDispatcherRefetchProfileAsync: Instruct a live connected device to refresh their profile
	* This command is understood by Comet Backup 17.12.0 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherRefetchProfileAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/refetch-profile", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRefetchProfile: Instruct a live connected device to refresh their profile
	* This command is understood by Comet Backup 17.12.0 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherRefetchProfile(String TargetID) throws ExecutionException, InterruptedException{
		return AdminDispatcherRefetchProfileAsync(TargetID).get();
	}

	/**
	* AdminDispatcherRegisterOfficeApplicationBeginAsync: Begin the process of registering a new Azure AD application that
	* can access Office 365 for backup
	* After calling this API, you should supply the login details to the end-user, and then begin polling the
	* AdminDispatcherRegisterOfficeApplicationCheck with the supplied &#34;Continuation&#34; parameter to check on the
	* registration process.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param EmailAddress The email address of the Azure AD administrator
	* @return CompletableFuture yielding a RegisterOfficeApplicationBeginResponse
	*/
	public CompletableFuture<RegisterOfficeApplicationBeginResponse> AdminDispatcherRegisterOfficeApplicationBeginAsync(String TargetID, String EmailAddress)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("EmailAddress", EmailAddress);
		var resultFuture = new CompletableFuture<RegisterOfficeApplicationBeginResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/register-office-application/begin", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, RegisterOfficeApplicationBeginResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRegisterOfficeApplicationBegin: Begin the process of registering a new Azure AD application that can
	* access Office 365 for backup
	* After calling this API, you should supply the login details to the end-user, and then begin polling the
	* AdminDispatcherRegisterOfficeApplicationCheck with the supplied &#34;Continuation&#34; parameter to check on the
	* registration process.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param EmailAddress The email address of the Azure AD administrator
	* @return a RegisterOfficeApplicationBeginResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public RegisterOfficeApplicationBeginResponse AdminDispatcherRegisterOfficeApplicationBegin(String TargetID, String EmailAddress) throws ExecutionException, InterruptedException{
		return AdminDispatcherRegisterOfficeApplicationBeginAsync(TargetID, EmailAddress).get();
	}

	/**
	* AdminDispatcherRegisterOfficeApplicationCheckAsync: Check the process of registering a new Azure AD application that
	* can access Office 365 for backup
	* You should begin the process by calling AdminDispatcherRegisterOfficeApplicationBegin and asking the end-user to
	* complete the Azure authentication steps.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Continuation The ID returned from the AdminDispatcherRegisterOfficeApplicationBegin endpoint
	* @return CompletableFuture yielding a RegisterOfficeApplicationCheckResponse
	*/
	public CompletableFuture<RegisterOfficeApplicationCheckResponse> AdminDispatcherRegisterOfficeApplicationCheckAsync(String TargetID, String Continuation)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Continuation", Continuation);
		var resultFuture = new CompletableFuture<RegisterOfficeApplicationCheckResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/register-office-application/check", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, RegisterOfficeApplicationCheckResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRegisterOfficeApplicationCheck: Check the process of registering a new Azure AD application that can
	* access Office 365 for backup
	* You should begin the process by calling AdminDispatcherRegisterOfficeApplicationBegin and asking the end-user to
	* complete the Azure authentication steps.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Continuation The ID returned from the AdminDispatcherRegisterOfficeApplicationBegin endpoint
	* @return a RegisterOfficeApplicationCheckResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public RegisterOfficeApplicationCheckResponse AdminDispatcherRegisterOfficeApplicationCheck(String TargetID, String Continuation) throws ExecutionException, InterruptedException{
		return AdminDispatcherRegisterOfficeApplicationCheckAsync(TargetID, Continuation).get();
	}

	/**
	* AdminDispatcherReindexStorageVaultAsync: Instruct a live connected device to rebuild Storage Vault indexes now
	* This command is understood by Comet Backup 18.6.9 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherReindexStorageVaultAsync(String TargetID, String Destination)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/reindex-storage-vault", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherReindexStorageVault: Instruct a live connected device to rebuild Storage Vault indexes now
	* This command is understood by Comet Backup 18.6.9 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherReindexStorageVault(String TargetID, String Destination) throws ExecutionException, InterruptedException{
		return AdminDispatcherReindexStorageVaultAsync(TargetID, Destination).get();
	}

	/**
	* AdminDispatcherRequestBrowseDiskDrivesAsync: Request a list of physical disk drive information from a live connected
	* device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a BrowseDiskDrivesResponse
	*/
	public CompletableFuture<BrowseDiskDrivesResponse> AdminDispatcherRequestBrowseDiskDrivesAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<BrowseDiskDrivesResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-browse-disk-drives", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseDiskDrivesResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestBrowseDiskDrives: Request a list of physical disk drive information from a live connected
	* device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a BrowseDiskDrivesResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BrowseDiskDrivesResponse AdminDispatcherRequestBrowseDiskDrives(String TargetID) throws ExecutionException, InterruptedException{
		return AdminDispatcherRequestBrowseDiskDrivesAsync(TargetID).get();
	}

	/**
	* AdminDispatcherRequestBrowseExchangeEdbAsync: Request a list of Exchange EDB databases from a live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a BrowseEDBResponse
	*/
	public CompletableFuture<BrowseEDBResponse> AdminDispatcherRequestBrowseExchangeEdbAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<BrowseEDBResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-browse-exchange-edb", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseEDBResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestBrowseExchangeEdb: Request a list of Exchange EDB databases from a live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a BrowseEDBResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BrowseEDBResponse AdminDispatcherRequestBrowseExchangeEdb(String TargetID) throws ExecutionException, InterruptedException{
		return AdminDispatcherRequestBrowseExchangeEdbAsync(TargetID).get();
	}

	/**
	* AdminDispatcherRequestBrowseHypervAsync: Request a list of Hyper-V virtual machines from a live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a BrowseHVResponse
	*/
	public CompletableFuture<BrowseHVResponse> AdminDispatcherRequestBrowseHypervAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<BrowseHVResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-browse-hyperv", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseHVResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestBrowseHyperv: Request a list of Hyper-V virtual machines from a live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a BrowseHVResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BrowseHVResponse AdminDispatcherRequestBrowseHyperv(String TargetID) throws ExecutionException, InterruptedException{
		return AdminDispatcherRequestBrowseHypervAsync(TargetID).get();
	}

	/**
	* AdminDispatcherRequestBrowseMongodbAsync: Request a list of tables in MongoDB database
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Mongo database authentication settings
	* @return CompletableFuture yielding a BrowseSQLServerResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseSQLServerResponse> AdminDispatcherRequestBrowseMongodbAsync(String TargetID, MongoDBConnection Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseSQLServerResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-browse-mongodb", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseSQLServerResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestBrowseMongodb: Request a list of tables in MongoDB database
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Mongo database authentication settings
	* @return a BrowseSQLServerResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseSQLServerResponse AdminDispatcherRequestBrowseMongodb(String TargetID, MongoDBConnection Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRequestBrowseMongodbAsync(TargetID, Credentials).get();
	}

	/**
	* AdminDispatcherRequestBrowseMssqlAsync: Request a list of tables in MSSQL database
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MSSQL database authentication settings
	* @return CompletableFuture yielding a BrowseSQLServerResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseSQLServerResponse> AdminDispatcherRequestBrowseMssqlAsync(String TargetID, MSSQLConnection Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseSQLServerResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-browse-mssql", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseSQLServerResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestBrowseMssql: Request a list of tables in MSSQL database
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MSSQL database authentication settings
	* @return a BrowseSQLServerResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseSQLServerResponse AdminDispatcherRequestBrowseMssql(String TargetID, MSSQLConnection Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRequestBrowseMssqlAsync(TargetID, Credentials).get();
	}

	/**
	* AdminDispatcherRequestBrowseMysqlAsync: Request a list of tables in MySQL database
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MySQL database authentication settings
	* @return CompletableFuture yielding a BrowseSQLServerResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseSQLServerResponse> AdminDispatcherRequestBrowseMysqlAsync(String TargetID, MySQLConnection Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseSQLServerResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-browse-mysql", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseSQLServerResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestBrowseMysql: Request a list of tables in MySQL database
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MySQL database authentication settings
	* @return a BrowseSQLServerResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseSQLServerResponse AdminDispatcherRequestBrowseMysql(String TargetID, MySQLConnection Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRequestBrowseMysqlAsync(TargetID, Credentials).get();
	}

	/**
	* AdminDispatcherRequestBrowseVmwareAsync: Request a list of VMware vSphere virtual machines
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The VMware vSphere connection settings
	* @return CompletableFuture yielding a BrowseVMwareResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseVMwareResponse> AdminDispatcherRequestBrowseVmwareAsync(String TargetID, VMwareConnection Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseVMwareResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-browse-vmware", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseVMwareResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestBrowseVmware: Request a list of VMware vSphere virtual machines
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The VMware vSphere connection settings
	* @return a BrowseVMwareResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseVMwareResponse AdminDispatcherRequestBrowseVmware(String TargetID, VMwareConnection Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRequestBrowseVmwareAsync(TargetID, Credentials).get();
	}

	/**
	* AdminDispatcherRequestBrowseVssAawAsync: Request a list of installed VSS Writers (Application-Aware Writers) from a
	* live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a BrowseVSSResponse
	*/
	public CompletableFuture<BrowseVSSResponse> AdminDispatcherRequestBrowseVssAawAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<BrowseVSSResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-browse-vss-aaw", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseVSSResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestBrowseVssAaw: Request a list of installed VSS Writers (Application-Aware Writers) from a live
	* connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a BrowseVSSResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BrowseVSSResponse AdminDispatcherRequestBrowseVssAaw(String TargetID) throws ExecutionException, InterruptedException{
		return AdminDispatcherRequestBrowseVssAawAsync(TargetID).get();
	}

	/**
	* AdminDispatcherRequestFilesystemObjectsAsync: Request a list of filesystem objects from a live connected device
	* The device must have granted the administrator permission to view its filenames.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Path (Optional) Browse objects inside this path. If empty or not present, returns the top-level device paths
	* @return CompletableFuture yielding a DispatcherStoredObjectsResponse
	*/
	public CompletableFuture<DispatcherStoredObjectsResponse> AdminDispatcherRequestFilesystemObjectsAsync(String TargetID, String Path)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		if (Path != null) data.put("Path",  Path);
		var resultFuture = new CompletableFuture<DispatcherStoredObjectsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-filesystem-objects", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherStoredObjectsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestFilesystemObjects: Request a list of filesystem objects from a live connected device
	* The device must have granted the administrator permission to view its filenames.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Path (Optional) Browse objects inside this path. If empty or not present, returns the top-level device paths
	* @return a DispatcherStoredObjectsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public DispatcherStoredObjectsResponse AdminDispatcherRequestFilesystemObjects(String TargetID, String Path) throws ExecutionException, InterruptedException{
		return AdminDispatcherRequestFilesystemObjectsAsync(TargetID, Path).get();
	}

	/**
	* AdminDispatcherRequestImportSourcesAsync: Request a list of import sources from a live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a DispatcherAdminSourcesResponse
	*/
	public CompletableFuture<DispatcherAdminSourcesResponse> AdminDispatcherRequestImportSourcesAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<DispatcherAdminSourcesResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-import-sources", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherAdminSourcesResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestImportSources: Request a list of import sources from a live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a DispatcherAdminSourcesResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public DispatcherAdminSourcesResponse AdminDispatcherRequestImportSources(String TargetID) throws ExecutionException, InterruptedException{
		return AdminDispatcherRequestImportSourcesAsync(TargetID).get();
	}

	/**
	* AdminDispatcherRequestOffice365AccountsAsync: Request a list of Office365 mailbox accounts
	* The remote device must have given consent for an MSP to browse their files.
	* This is primarily used for testing the connection to Graph API, not for actual listing
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return CompletableFuture yielding a BrowseOffice365ObjectsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseOffice365ObjectsResponse> AdminDispatcherRequestOffice365AccountsAsync(String TargetID, Office365Credential Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseOffice365ObjectsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-office365-accounts", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseOffice365ObjectsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestOffice365Accounts: Request a list of Office365 mailbox accounts
	* The remote device must have given consent for an MSP to browse their files.
	* This is primarily used for testing the connection to Graph API, not for actual listing
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return a BrowseOffice365ObjectsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseOffice365ObjectsResponse AdminDispatcherRequestOffice365Accounts(String TargetID, Office365Credential Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRequestOffice365AccountsAsync(TargetID, Credentials).get();
	}

	/**
	* AdminDispatcherRequestOffice365SitesAsync: Request a list of Office365 sites
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return CompletableFuture yielding a BrowseOffice365ObjectsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseOffice365ObjectsResponse> AdminDispatcherRequestOffice365SitesAsync(String TargetID, Office365Credential Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseOffice365ObjectsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-office365-sites", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseOffice365ObjectsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestOffice365Sites: Request a list of Office365 sites
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return a BrowseOffice365ObjectsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseOffice365ObjectsResponse AdminDispatcherRequestOffice365Sites(String TargetID, Office365Credential Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRequestOffice365SitesAsync(TargetID, Credentials).get();
	}

	/**
	* AdminDispatcherRequestStoredObjectsAsync: Request a list of stored objects inside an existing backup job
	* The remote device must have given consent for an MSP to browse their files.
	* To service this request, the remote device must connect to the Storage Vault and load index data. There may be a
	* small delay. If the remote device is running Comet 20.12.0 or later, the necessary index data is cached when this API
	* is first called, for 15 minutes after the last repeated call. This can improve performance for interactively browsing
	* an entire tree of stored objects.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @param SnapshotID The selected backup job snapshot
	* @param TreeID (Optional) Browse objects inside subdirectory of backup snapshot. If it is for VMDK single file
	* restore, it should be the disk image&#39;s subtree ID.
	* @param Options (Optional) Request a list of stored objects in vmdk file
	* @return CompletableFuture yielding a DispatcherStoredObjectsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<DispatcherStoredObjectsResponse> AdminDispatcherRequestStoredObjectsAsync(String TargetID, String Destination, String SnapshotID, String TreeID, VMDKSnapshotViewOptions Options) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		data.put("SnapshotID", SnapshotID);
		if (TreeID != null) data.put("TreeID",  TreeID);
		if (Options != null) data.put("Options", CometAPI.getObjectMapper().writeValueAsString(Options));
		var resultFuture = new CompletableFuture<DispatcherStoredObjectsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-stored-objects", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherStoredObjectsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestStoredObjects: Request a list of stored objects inside an existing backup job
	* The remote device must have given consent for an MSP to browse their files.
	* To service this request, the remote device must connect to the Storage Vault and load index data. There may be a
	* small delay. If the remote device is running Comet 20.12.0 or later, the necessary index data is cached when this API
	* is first called, for 15 minutes after the last repeated call. This can improve performance for interactively browsing
	* an entire tree of stored objects.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @param SnapshotID The selected backup job snapshot
	* @param TreeID (Optional) Browse objects inside subdirectory of backup snapshot. If it is for VMDK single file
	* restore, it should be the disk image&#39;s subtree ID.
	* @param Options (Optional) Request a list of stored objects in vmdk file
	* @return a DispatcherStoredObjectsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public DispatcherStoredObjectsResponse AdminDispatcherRequestStoredObjects(String TargetID, String Destination, String SnapshotID, String TreeID, VMDKSnapshotViewOptions Options) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRequestStoredObjectsAsync(TargetID, Destination, SnapshotID, TreeID, Options).get();
	}

	/**
	* AdminDispatcherRequestVaultSnapshotsAsync: Request a list of Storage Vault snapshots from a live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @return CompletableFuture yielding a DispatcherVaultSnapshotsResponse
	*/
	public CompletableFuture<DispatcherVaultSnapshotsResponse> AdminDispatcherRequestVaultSnapshotsAsync(String TargetID, String Destination)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		var resultFuture = new CompletableFuture<DispatcherVaultSnapshotsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-vault-snapshots", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherVaultSnapshotsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestVaultSnapshots: Request a list of Storage Vault snapshots from a live connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @return a DispatcherVaultSnapshotsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public DispatcherVaultSnapshotsResponse AdminDispatcherRequestVaultSnapshots(String TargetID, String Destination) throws ExecutionException, InterruptedException{
		return AdminDispatcherRequestVaultSnapshotsAsync(TargetID, Destination).get();
	}

	/**
	* AdminDispatcherRequestWindiskSnapshotAsync: Request a Disk Image snapshot with the windiskbrowse-style from a live
	* connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @param SnapshotID The Snapshot ID
	* @return CompletableFuture yielding a DispatcherWindiskSnapshotResponse
	*/
	public CompletableFuture<DispatcherWindiskSnapshotResponse> AdminDispatcherRequestWindiskSnapshotAsync(String TargetID, String Destination, String SnapshotID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		data.put("SnapshotID", SnapshotID);
		var resultFuture = new CompletableFuture<DispatcherWindiskSnapshotResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/request-windisk-snapshot", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherWindiskSnapshotResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRequestWindiskSnapshot: Request a Disk Image snapshot with the windiskbrowse-style from a live
	* connected device
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @param SnapshotID The Snapshot ID
	* @return a DispatcherWindiskSnapshotResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public DispatcherWindiskSnapshotResponse AdminDispatcherRequestWindiskSnapshot(String TargetID, String Destination, String SnapshotID) throws ExecutionException, InterruptedException{
		return AdminDispatcherRequestWindiskSnapshotAsync(TargetID, Destination, SnapshotID).get();
	}

	/**
	* AdminDispatcherRunBackupAsync: Instruct a live connected device to run a scheduled backup
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param BackupRule The schedule GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherRunBackupAsync(String TargetID, String BackupRule)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("BackupRule", BackupRule);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/run-backup", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRunBackup: Instruct a live connected device to run a scheduled backup
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param BackupRule The schedule GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherRunBackup(String TargetID, String BackupRule) throws ExecutionException, InterruptedException{
		return AdminDispatcherRunBackupAsync(TargetID, BackupRule).get();
	}

	/**
	* AdminDispatcherRunBackupCustomAsync: Instruct a live connected device to run a backup
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Source The Protected Item GUID
	* @param Destination The Storage Vault GUID
	* @param Options (Optional) Extra job parameters (&gt;= 19.3.6)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherRunBackupCustomAsync(String TargetID, String Source, String Destination, BackupJobAdvancedOptions Options) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Source", Source);
		data.put("Destination", Destination);
		if (Options != null) data.put("Options", CometAPI.getObjectMapper().writeValueAsString(Options));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/run-backup-custom", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRunBackupCustom: Instruct a live connected device to run a backup
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Source The Protected Item GUID
	* @param Destination The Storage Vault GUID
	* @param Options (Optional) Extra job parameters (&gt;= 19.3.6)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDispatcherRunBackupCustom(String TargetID, String Source, String Destination, BackupJobAdvancedOptions Options) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRunBackupCustomAsync(TargetID, Source, Destination, Options).get();
	}

	/**
	* AdminDispatcherRunRestoreAsync: Instruct a live connected device to perform a local restore
	* This command is understood by Comet Backup 17.9.3 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Path The local path to restore to
	* @param Source The Protected Item ID
	* @param Destination The Storage Vault ID
	* @param Snapshot (Optional) If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the
	* selected Protected Item + Storage Vault pair
	* @param Paths (Optional) If present, restore these paths only. Otherwise, restore all data (&gt;= 19.3.0)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherRunRestoreAsync(String TargetID, String Path, String Source, String Destination, String Snapshot, String[] Paths) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Path", Path);
		data.put("Source", Source);
		data.put("Destination", Destination);
		if (Snapshot != null) data.put("Snapshot",  Snapshot);
		if (Paths != null) data.put("Paths", CometAPI.getObjectMapper().writeValueAsString(Paths));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/run-restore", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRunRestore: Instruct a live connected device to perform a local restore
	* This command is understood by Comet Backup 17.9.3 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Path The local path to restore to
	* @param Source The Protected Item ID
	* @param Destination The Storage Vault ID
	* @param Snapshot (Optional) If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the
	* selected Protected Item + Storage Vault pair
	* @param Paths (Optional) If present, restore these paths only. Otherwise, restore all data (&gt;= 19.3.0)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDispatcherRunRestore(String TargetID, String Path, String Source, String Destination, String Snapshot, String[] Paths) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRunRestoreAsync(TargetID, Path, Source, Destination, Snapshot, Paths).get();
	}

	/**
	* AdminDispatcherRunRestoreCustomAsync: Instruct a live connected device to perform a local restore
	* This command is understood by Comet Backup 18.6.0 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Source The Protected Item ID
	* @param Destination The Storage Vault ID
	* @param Options Restore targets
	* @param Snapshot (Optional) If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the
	* selected Protected Item + Storage Vault pair
	* @param Paths (Optional) If present, restore these paths only. Otherwise, restore all data
	* @param KnownFileCount (Optional) The number of files to restore, if known. Supplying this means we don&#39;t need to
	* walk the entire tree just to find the file count and will speed up the restoration process.
	* @param KnownByteCount (Optional) The total size in bytes of files to restore, if known. Supplying this means we
	* don&#39;t need to walk the entire tree just to find the total file size and will speed up the restoration process.
	* @param KnownDirCount (Optional) The number of directories to restore, if known. Supplying this means we don&#39;t
	* need to walk the entire tree just to find the number of directories and will speed up the restoration process.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherRunRestoreCustomAsync(String TargetID, String Source, String Destination, RestoreJobAdvancedOptions Options, String Snapshot, String[] Paths, Integer KnownFileCount, Integer KnownByteCount, Integer KnownDirCount) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Source", Source);
		data.put("Destination", Destination);
		data.put("Options", CometAPI.getObjectMapper().writeValueAsString(Options));
		if (Snapshot != null) data.put("Snapshot",  Snapshot);
		if (Paths != null) data.put("Paths", CometAPI.getObjectMapper().writeValueAsString(Paths));
		if (KnownFileCount != null) data.put("KnownFileCount", CometAPI.getObjectMapper().writeValueAsString(KnownFileCount));
		if (KnownByteCount != null) data.put("KnownByteCount", CometAPI.getObjectMapper().writeValueAsString(KnownByteCount));
		if (KnownDirCount != null) data.put("KnownDirCount", CometAPI.getObjectMapper().writeValueAsString(KnownDirCount));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/run-restore-custom", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherRunRestoreCustom: Instruct a live connected device to perform a local restore
	* This command is understood by Comet Backup 18.6.0 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Source The Protected Item ID
	* @param Destination The Storage Vault ID
	* @param Options Restore targets
	* @param Snapshot (Optional) If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the
	* selected Protected Item + Storage Vault pair
	* @param Paths (Optional) If present, restore these paths only. Otherwise, restore all data
	* @param KnownFileCount (Optional) The number of files to restore, if known. Supplying this means we don&#39;t need to
	* walk the entire tree just to find the file count and will speed up the restoration process.
	* @param KnownByteCount (Optional) The total size in bytes of files to restore, if known. Supplying this means we
	* don&#39;t need to walk the entire tree just to find the total file size and will speed up the restoration process.
	* @param KnownDirCount (Optional) The number of directories to restore, if known. Supplying this means we don&#39;t
	* need to walk the entire tree just to find the number of directories and will speed up the restoration process.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDispatcherRunRestoreCustom(String TargetID, String Source, String Destination, RestoreJobAdvancedOptions Options, String Snapshot, String[] Paths, Integer KnownFileCount, Integer KnownByteCount, Integer KnownDirCount) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherRunRestoreCustomAsync(TargetID, Source, Destination, Options, Snapshot, Paths, KnownFileCount, KnownByteCount, KnownDirCount).get();
	}

	/**
	* AdminDispatcherSearchSnapshotsAsync: Search storage vault snapshots
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotIDs Snapshots to search
	* @param Filter The search filter
	* @return CompletableFuture yielding a SearchSnapshotsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<SearchSnapshotsResponse> AdminDispatcherSearchSnapshotsAsync(String TargetID, String DestinationID, String[] SnapshotIDs, SearchClause Filter) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("DestinationID", DestinationID);
		data.put("SnapshotIDs", CometAPI.getObjectMapper().writeValueAsString(SnapshotIDs));
		data.put("Filter", CometAPI.getObjectMapper().writeValueAsString(Filter));
		var resultFuture = new CompletableFuture<SearchSnapshotsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/search-snapshots", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, SearchSnapshotsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherSearchSnapshots: Search storage vault snapshots
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotIDs Snapshots to search
	* @param Filter The search filter
	* @return a SearchSnapshotsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public SearchSnapshotsResponse AdminDispatcherSearchSnapshots(String TargetID, String DestinationID, String[] SnapshotIDs, SearchClause Filter) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherSearchSnapshotsAsync(TargetID, DestinationID, SnapshotIDs, Filter).get();
	}

	/**
	* AdminDispatcherTestSmbAuthAsync: Test a set of Windows SMB credentials
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Wsa The target credentials to test
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherTestSmbAuthAsync(String TargetID, WinSMBAuth Wsa) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Wsa", CometAPI.getObjectMapper().writeValueAsString(Wsa));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/test-smb-auth", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherTestSmbAuth: Test a set of Windows SMB credentials
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Wsa The target credentials to test
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDispatcherTestSmbAuth(String TargetID, WinSMBAuth Wsa) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherTestSmbAuthAsync(TargetID, Wsa).get();
	}

	/**
	* AdminDispatcherUninstallSoftwareAsync: Instruct a live connected device to self-uninstall the software
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param RemoveConfigFile Determine if the config.dat file will be deleted at the same time
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherUninstallSoftwareAsync(String TargetID, Boolean RemoveConfigFile) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("RemoveConfigFile", CometAPI.getObjectMapper().writeValueAsString(RemoveConfigFile));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/uninstall-software", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherUninstallSoftware: Instruct a live connected device to self-uninstall the software
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param RemoveConfigFile Determine if the config.dat file will be deleted at the same time
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDispatcherUninstallSoftware(String TargetID, Boolean RemoveConfigFile) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherUninstallSoftwareAsync(TargetID, RemoveConfigFile).get();
	}

	/**
	* AdminDispatcherUnlockAsync: Instruct a live connected device to remove lock files from a Storage Vault
	* Misuse can cause data loss!
	* This command is understood by Comet Backup 17.9.4 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherUnlockAsync(String TargetID, String Destination)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/unlock", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherUnlock: Instruct a live connected device to remove lock files from a Storage Vault
	* Misuse can cause data loss!
	* This command is understood by Comet Backup 17.9.4 and newer.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherUnlock(String TargetID, String Destination) throws ExecutionException, InterruptedException{
		return AdminDispatcherUnlockAsync(TargetID, Destination).get();
	}

	/**
	* AdminDispatcherUpdateLoginUrlAsync: Instruct a live connected device to update its login server URL
	* The device will attempt to connect to the new Auth Role Comet Server using its current username and password. If the
	* test connection succeeds, the device migrates its saved connection settings and live connections to the new server.
	* If the device is not registered on the new URL, or if the credentials are incorrect, the device remains on the
	* current Auth Role server.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param NewURL The new external URL of this server
	* @param Force (Optional) No checks will be done using previous URL
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherUpdateLoginUrlAsync(String TargetID, String NewURL, Boolean Force) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("NewURL", NewURL);
		if (Force != null) data.put("Force", CometAPI.getObjectMapper().writeValueAsString(Force));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/update-login-url", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherUpdateLoginUrl: Instruct a live connected device to update its login server URL
	* The device will attempt to connect to the new Auth Role Comet Server using its current username and password. If the
	* test connection succeeds, the device migrates its saved connection settings and live connections to the new server.
	* If the device is not registered on the new URL, or if the credentials are incorrect, the device remains on the
	* current Auth Role server.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param NewURL The new external URL of this server
	* @param Force (Optional) No checks will be done using previous URL
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminDispatcherUpdateLoginUrl(String TargetID, String NewURL, Boolean Force) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminDispatcherUpdateLoginUrlAsync(TargetID, NewURL, Force).get();
	}

	/**
	* AdminDispatcherUpdateSoftwareAsync: Instruct a live connected device to download a software update
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* This API requires the Software Build Role to be enabled.
	* @param TargetID The live connection GUID
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts (&gt;= 19.3.11)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminDispatcherUpdateSoftwareAsync(String TargetID, String SelfAddress)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/dispatcher/update-software", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminDispatcherUpdateSoftware: Instruct a live connected device to download a software update
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* This API requires the Software Build Role to be enabled.
	* @param TargetID The live connection GUID
	* @param SelfAddress (Optional) The external URL of this server, used to resolve conflicts (&gt;= 19.3.11)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminDispatcherUpdateSoftware(String TargetID, String SelfAddress) throws ExecutionException, InterruptedException{
		return AdminDispatcherUpdateSoftwareAsync(TargetID, SelfAddress).get();
	}

	/**
	* AdminExternalAuthSourcesDeleteAsync: Delete an external admin authentication source
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SourceID (No description available)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminExternalAuthSourcesDeleteAsync(String SourceID)  {
		var data = new HashMap<String,String>();

		data.put("SourceID", SourceID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/external-auth-sources/delete", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminExternalAuthSourcesDelete: Delete an external admin authentication source
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param SourceID (No description available)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminExternalAuthSourcesDelete(String SourceID) throws ExecutionException, InterruptedException{
		return AdminExternalAuthSourcesDeleteAsync(SourceID).get();
	}

	/**
	* AdminExternalAuthSourcesGetAsync: Get a map of all external admin authentication sources
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return CompletableFuture yielding a HashMap&lt;String,ExternalAuthenticationSource&gt;
	*/
	public CompletableFuture<HashMap<String,ExternalAuthenticationSource>> AdminExternalAuthSourcesGetAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,ExternalAuthenticationSource>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/external-auth-sources/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, ExternalAuthenticationSource.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminExternalAuthSourcesGet: Get a map of all external admin authentication sources
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return a HashMap&lt;String,ExternalAuthenticationSource&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,ExternalAuthenticationSource> AdminExternalAuthSourcesGet() throws ExecutionException, InterruptedException{
		return AdminExternalAuthSourcesGetAsync().get();
	}

	/**
	* AdminExternalAuthSourcesNewAsync: Create an external admin authentication source
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Source (No description available)
	* @param SourceID (Optional) (No description available)
	* @return CompletableFuture yielding an ExternalAuthenticationSourceResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<ExternalAuthenticationSourceResponse> AdminExternalAuthSourcesNewAsync(ExternalAuthenticationSource Source, String SourceID) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Source", CometAPI.getObjectMapper().writeValueAsString(Source));
		if (SourceID != null) data.put("SourceID",  SourceID);
		var resultFuture = new CompletableFuture<ExternalAuthenticationSourceResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/external-auth-sources/new", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ExternalAuthenticationSourceResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminExternalAuthSourcesNew: Create an external admin authentication source
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Source (No description available)
	* @param SourceID (Optional) (No description available)
	* @return an ExternalAuthenticationSourceResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public ExternalAuthenticationSourceResponse AdminExternalAuthSourcesNew(ExternalAuthenticationSource Source, String SourceID) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminExternalAuthSourcesNewAsync(Source, SourceID).get();
	}

	/**
	* AdminExternalAuthSourcesSetAsync: Updates the current tenant&#39;s external admin authentication sources. This will
	* set all
	* sources for the tenant; none will be preserved.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Sources (No description available)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminExternalAuthSourcesSetAsync(HashMap<String,ExternalAuthenticationSource> Sources) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Sources", CometAPI.getObjectMapper().writeValueAsString(Sources));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/external-auth-sources/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminExternalAuthSourcesSet: Updates the current tenant&#39;s external admin authentication sources. This will set
	* all
	* sources for the tenant; none will be preserved.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Sources (No description available)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminExternalAuthSourcesSet(HashMap<String,ExternalAuthenticationSource> Sources) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminExternalAuthSourcesSetAsync(Sources).get();
	}

	/**
	* AdminGetJobLogAsync: Get the report log entries for a single job, in plaintext format
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job ID
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminGetJobLogAsync(String JobID)  {
		var data = new HashMap<String,String>();

		data.put("JobID", JobID);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-job-log", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetJobLog: Get the report log entries for a single job, in plaintext format
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job ID
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminGetJobLog(String JobID) throws ExecutionException, InterruptedException{
		return AdminGetJobLogAsync(JobID).get();
	}

	/**
	* AdminGetJobLogEntriesAsync: Get the report log entries for a single job
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job ID
	* @param MinSeverity (Optional) Return only job log entries with equal or higher severity
	* @param MessageContains (Optional) Return only job log entries that contain exact string
	* @return CompletableFuture yielding a JobEntry[]
	*/
	public CompletableFuture<JobEntry[]> AdminGetJobLogEntriesAsync(String JobID, String MinSeverity, String MessageContains)  {
		var data = new HashMap<String,String>();

		data.put("JobID", JobID);
		if (MinSeverity != null) data.put("MinSeverity",  MinSeverity);
		if (MessageContains != null) data.put("MessageContains",  MessageContains);
		var resultFuture = new CompletableFuture<JobEntry[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-job-log-entries", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, JobEntry[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetJobLogEntries: Get the report log entries for a single job
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job ID
	* @param MinSeverity (Optional) Return only job log entries with equal or higher severity
	* @param MessageContains (Optional) Return only job log entries that contain exact string
	* @return a JobEntry[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public JobEntry[] AdminGetJobLogEntries(String JobID, String MinSeverity, String MessageContains) throws ExecutionException, InterruptedException{
		return AdminGetJobLogEntriesAsync(JobID, MinSeverity, MessageContains).get();
	}

	/**
	* AdminGetJobPropertiesAsync: Get properties of a single job
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job ID
	* @return CompletableFuture yielding a BackupJobDetail
	*/
	public CompletableFuture<BackupJobDetail> AdminGetJobPropertiesAsync(String JobID)  {
		var data = new HashMap<String,String>();

		data.put("JobID", JobID);
		var resultFuture = new CompletableFuture<BackupJobDetail>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-job-properties", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetJobProperties: Get properties of a single job
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job ID
	* @return a BackupJobDetail
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BackupJobDetail AdminGetJobProperties(String JobID) throws ExecutionException, InterruptedException{
		return AdminGetJobPropertiesAsync(JobID).get();
	}

	/**
	* AdminGetJobsAllAsync: Get jobs (All)
	* The jobs are returned in an unspecified order.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a BackupJobDetail[]
	*/
	public CompletableFuture<BackupJobDetail[]> AdminGetJobsAllAsync()  {
		var resultFuture = new CompletableFuture<BackupJobDetail[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-jobs-all", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetJobsAll: Get jobs (All)
	* The jobs are returned in an unspecified order.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return a BackupJobDetail[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BackupJobDetail[] AdminGetJobsAll() throws ExecutionException, InterruptedException{
		return AdminGetJobsAllAsync().get();
	}

	/**
	* AdminGetJobsForCustomSearchAsync: Get jobs (for custom search)
	* The jobs are returned in an unspecified order.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Query (No description available)
	* @return CompletableFuture yielding a BackupJobDetail[]
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BackupJobDetail[]> AdminGetJobsForCustomSearchAsync(SearchClause Query) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Query", CometAPI.getObjectMapper().writeValueAsString(Query));
		var resultFuture = new CompletableFuture<BackupJobDetail[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-jobs-for-custom-search", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetJobsForCustomSearch: Get jobs (for custom search)
	* The jobs are returned in an unspecified order.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Query (No description available)
	* @return a BackupJobDetail[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BackupJobDetail[] AdminGetJobsForCustomSearch(SearchClause Query) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminGetJobsForCustomSearchAsync(Query).get();
	}

	/**
	* AdminGetJobsForDateRangeAsync: Get jobs (for date range)
	* The jobs are returned in an unspecified order.
	* 
	* If the `Start` parameter is later than `End`, they will be swapped.
	* 
	* This API will return all jobs that either started or ended within the supplied range.
	* 
	* Incomplete jobs have an end time of `0`. You can use this API to find only incomplete jobs by setting both `Start`
	* and `End` to `0`.
	* 
	* Prior to Comet Server 22.6.0, additional Incomplete jobs may have been returned if you specified non-zero arguments
	* for both `Start` and `End`.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Start Timestamp (Unix)
	* @param End Timestamp (Unix)
	* @return CompletableFuture yielding a BackupJobDetail[]
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BackupJobDetail[]> AdminGetJobsForDateRangeAsync(Integer Start, Integer End) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Start", CometAPI.getObjectMapper().writeValueAsString(Start));
		data.put("End", CometAPI.getObjectMapper().writeValueAsString(End));
		var resultFuture = new CompletableFuture<BackupJobDetail[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-jobs-for-date-range", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetJobsForDateRange: Get jobs (for date range)
	* The jobs are returned in an unspecified order.
	* 
	* If the `Start` parameter is later than `End`, they will be swapped.
	* 
	* This API will return all jobs that either started or ended within the supplied range.
	* 
	* Incomplete jobs have an end time of `0`. You can use this API to find only incomplete jobs by setting both `Start`
	* and `End` to `0`.
	* 
	* Prior to Comet Server 22.6.0, additional Incomplete jobs may have been returned if you specified non-zero arguments
	* for both `Start` and `End`.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Start Timestamp (Unix)
	* @param End Timestamp (Unix)
	* @return a BackupJobDetail[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BackupJobDetail[] AdminGetJobsForDateRange(Integer Start, Integer End) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminGetJobsForDateRangeAsync(Start, End).get();
	}

	/**
	* AdminGetJobsForUserAsync: Get jobs (for user)
	* The jobs are returned in an unspecified order.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected username
	* @return CompletableFuture yielding a BackupJobDetail[]
	*/
	public CompletableFuture<BackupJobDetail[]> AdminGetJobsForUserAsync(String TargetUser)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		var resultFuture = new CompletableFuture<BackupJobDetail[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-jobs-for-user", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetJobsForUser: Get jobs (for user)
	* The jobs are returned in an unspecified order.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected username
	* @return a BackupJobDetail[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BackupJobDetail[] AdminGetJobsForUser(String TargetUser) throws ExecutionException, InterruptedException{
		return AdminGetJobsForUserAsync(TargetUser).get();
	}

	/**
	* AdminGetJobsRecentAsync: Get jobs (Recent and incomplete)
	* The jobs are returned in an unspecified order.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a BackupJobDetail[]
	*/
	public CompletableFuture<BackupJobDetail[]> AdminGetJobsRecentAsync()  {
		var resultFuture = new CompletableFuture<BackupJobDetail[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-jobs-recent", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetJobsRecent: Get jobs (Recent and incomplete)
	* The jobs are returned in an unspecified order.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return a BackupJobDetail[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BackupJobDetail[] AdminGetJobsRecent() throws ExecutionException, InterruptedException{
		return AdminGetJobsRecentAsync().get();
	}

	/**
	* AdminGetUserProfileAsync: Get user account profile
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @return CompletableFuture yielding an UserProfileConfig
	*/
	public CompletableFuture<UserProfileConfig> AdminGetUserProfileAsync(String TargetUser)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		var resultFuture = new CompletableFuture<UserProfileConfig>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-user-profile", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, UserProfileConfig.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetUserProfile: Get user account profile
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @return an UserProfileConfig
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public UserProfileConfig AdminGetUserProfile(String TargetUser) throws ExecutionException, InterruptedException{
		return AdminGetUserProfileAsync(TargetUser).get();
	}

	/**
	* AdminGetUserProfileAndHashAsync: Get user account profile (atomic)
	* The resulting hash parameter can be passed to the corresponding update API, to atomically ensure that no changes
	* occur between get/set operations.
	* The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve
	* current hash values.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @return CompletableFuture yielding a GetProfileAndHashResponseMessage
	*/
	public CompletableFuture<GetProfileAndHashResponseMessage> AdminGetUserProfileAndHashAsync(String TargetUser)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		var resultFuture = new CompletableFuture<GetProfileAndHashResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-user-profile-and-hash", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, GetProfileAndHashResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetUserProfileAndHash: Get user account profile (atomic)
	* The resulting hash parameter can be passed to the corresponding update API, to atomically ensure that no changes
	* occur between get/set operations.
	* The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve
	* current hash values.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @return a GetProfileAndHashResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public GetProfileAndHashResponseMessage AdminGetUserProfileAndHash(String TargetUser) throws ExecutionException, InterruptedException{
		return AdminGetUserProfileAndHashAsync(TargetUser).get();
	}

	/**
	* AdminGetUserProfileHashAsync: Get user account profile (hash)
	* The profile hash can be used to determine if a user account profile has changed.
	* The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve
	* current hash values.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @return CompletableFuture yielding a GetProfileHashResponseMessage
	*/
	public CompletableFuture<GetProfileHashResponseMessage> AdminGetUserProfileHashAsync(String TargetUser)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		var resultFuture = new CompletableFuture<GetProfileHashResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/get-user-profile-hash", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, GetProfileHashResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminGetUserProfileHash: Get user account profile (hash)
	* The profile hash can be used to determine if a user account profile has changed.
	* The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve
	* current hash values.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @return a GetProfileHashResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public GetProfileHashResponseMessage AdminGetUserProfileHash(String TargetUser) throws ExecutionException, InterruptedException{
		return AdminGetUserProfileHashAsync(TargetUser).get();
	}

	/**
	* AdminInstallationDispatchDropConnectionAsync: Instruct a live connected device to disconnect
	* The device will terminate its live-connection process and will not reconnect.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param DeviceID The live connection Device GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminInstallationDispatchDropConnectionAsync(String DeviceID)  {
		var data = new HashMap<String,String>();

		data.put("DeviceID", DeviceID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/installation/dispatch/drop-connection", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminInstallationDispatchDropConnection: Instruct a live connected device to disconnect
	* The device will terminate its live-connection process and will not reconnect.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param DeviceID The live connection Device GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminInstallationDispatchDropConnection(String DeviceID) throws ExecutionException, InterruptedException{
		return AdminInstallationDispatchDropConnectionAsync(DeviceID).get();
	}

	/**
	* AdminInstallationDispatchRegisterDeviceAsync: Instruct an unregistered device to authenticate with a given user
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param DeviceID The live connection Device GUID
	* @param TargetUser Selected account username
	* @param TargetPassword Selected account password
	* @param TargetTOTPCode (Optional) Selected account TOTP code
	* @return CompletableFuture yielding a String
	*/
	public CompletableFuture<String> AdminInstallationDispatchRegisterDeviceAsync(String DeviceID, String TargetUser, String TargetPassword, String TargetTOTPCode)  {
		var data = new HashMap<String,String>();

		data.put("DeviceID", DeviceID);
		data.put("TargetUser", TargetUser);
		data.put("TargetPassword", TargetPassword);
		if (TargetTOTPCode != null) data.put("TargetTOTPCode",  TargetTOTPCode);
		var resultFuture = new CompletableFuture<String>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/installation/dispatch/register-device", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, String.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminInstallationDispatchRegisterDevice: Instruct an unregistered device to authenticate with a given user
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param DeviceID The live connection Device GUID
	* @param TargetUser Selected account username
	* @param TargetPassword Selected account password
	* @param TargetTOTPCode (Optional) Selected account TOTP code
	* @return a String
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public String AdminInstallationDispatchRegisterDevice(String DeviceID, String TargetUser, String TargetPassword, String TargetTOTPCode) throws ExecutionException, InterruptedException{
		return AdminInstallationDispatchRegisterDeviceAsync(DeviceID, TargetUser, TargetPassword, TargetTOTPCode).get();
	}

	/**
	* AdminInstallationListActiveAsync: List live connected devices in lobby mode
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a HashMap&lt;String,RegistrationLobbyConnection&gt;
	*/
	public CompletableFuture<HashMap<String,RegistrationLobbyConnection>> AdminInstallationListActiveAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,RegistrationLobbyConnection>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/installation/list-active", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, RegistrationLobbyConnection.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminInstallationListActive: List live connected devices in lobby mode
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return a HashMap&lt;String,RegistrationLobbyConnection&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,RegistrationLobbyConnection> AdminInstallationListActive() throws ExecutionException, InterruptedException{
		return AdminInstallationListActiveAsync().get();
	}

	/**
	* AdminJobAbandonAsync: Mark a running job as abandoned
	* This will change the status of a running job to abandoned.
	* This is intended to be used on jobs which are definitely no longer running but are stuck in the running state; it
	* will not attempt to cancel the job. If the job is detected to still be running after being marked as abandoned, it
	* will be revived.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Username
	* @param JobID Job ID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminJobAbandonAsync(String TargetUser, String JobID)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("JobID", JobID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/job/abandon", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminJobAbandon: Mark a running job as abandoned
	* This will change the status of a running job to abandoned.
	* This is intended to be used on jobs which are definitely no longer running but are stuck in the running state; it
	* will not attempt to cancel the job. If the job is detected to still be running after being marked as abandoned, it
	* will be revived.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Username
	* @param JobID Job ID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminJobAbandon(String TargetUser, String JobID) throws ExecutionException, InterruptedException{
		return AdminJobAbandonAsync(TargetUser, JobID).get();
	}

	/**
	* AdminJobCancelAsync: Cancel a running job
	* A request is sent to the live-connected device, asking it to cancel the operation. This may fail if there is no
	* live-connection.
	* Only jobs from Comet 18.3.5 or newer can be cancelled. A job can only be cancelled if it has a non-empty
	* CancellationID field in its properties.
	* If the device is running Comet 21.9.5 or later, this API will wait up to ten seconds for a confirmation from the
	* client.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Username
	* @param JobID Job ID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminJobCancelAsync(String TargetUser, String JobID)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("JobID", JobID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/job/cancel", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminJobCancel: Cancel a running job
	* A request is sent to the live-connected device, asking it to cancel the operation. This may fail if there is no
	* live-connection.
	* Only jobs from Comet 18.3.5 or newer can be cancelled. A job can only be cancelled if it has a non-empty
	* CancellationID field in its properties.
	* If the device is running Comet 21.9.5 or later, this API will wait up to ten seconds for a confirmation from the
	* client.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Username
	* @param JobID Job ID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminJobCancel(String TargetUser, String JobID) throws ExecutionException, InterruptedException{
		return AdminJobCancelAsync(TargetUser, JobID).get();
	}

	/**
	* AdminListUsersAsync: List all user accounts
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a String[]
	*/
	public CompletableFuture<String[]> AdminListUsersAsync()  {
		var resultFuture = new CompletableFuture<String[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/list-users", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, String[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminListUsers: List all user accounts
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return a String[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public String[] AdminListUsers() throws ExecutionException, InterruptedException{
		return AdminListUsersAsync().get();
	}

	/**
	* AdminListUsersFullAsync: List all user account profiles
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a HashMap&lt;String,UserProfileConfig&gt;
	*/
	public CompletableFuture<HashMap<String,UserProfileConfig>> AdminListUsersFullAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,UserProfileConfig>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/list-users-full", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, UserProfileConfig.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminListUsersFull: List all user account profiles
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return a HashMap&lt;String,UserProfileConfig&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,UserProfileConfig> AdminListUsersFull() throws ExecutionException, InterruptedException{
		return AdminListUsersFullAsync().get();
	}

	/**
	* AdminMetaBrandingConfigGetAsync: Get Branding configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return CompletableFuture yielding a ServerConfigOptionsBrandingFragment
	*/
	public CompletableFuture<ServerConfigOptionsBrandingFragment> AdminMetaBrandingConfigGetAsync()  {
		var resultFuture = new CompletableFuture<ServerConfigOptionsBrandingFragment>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/branding-config/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ServerConfigOptionsBrandingFragment.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaBrandingConfigGet: Get Branding configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return a ServerConfigOptionsBrandingFragment
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ServerConfigOptionsBrandingFragment AdminMetaBrandingConfigGet() throws ExecutionException, InterruptedException{
		return AdminMetaBrandingConfigGetAsync().get();
	}

	/**
	* AdminMetaBrandingConfigSetAsync: Set Branding configuration
	* Note that file resources must be provided using a resource URI, i.e
	* `&#34;resource://05ba0b90ee66bda433169581188aba8d29faa938f9464cccd651a02fdf2e5b57&#34;`. See AdminMetaResourceNew for
	* the API documentation to create new file resources.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param BrandingConfig Updated configuration content
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaBrandingConfigSetAsync(BrandingOptions BrandingConfig) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("BrandingConfig", CometAPI.getObjectMapper().writeValueAsString(BrandingConfig));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/branding-config/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaBrandingConfigSet: Set Branding configuration
	* Note that file resources must be provided using a resource URI, i.e
	* `&#34;resource://05ba0b90ee66bda433169581188aba8d29faa938f9464cccd651a02fdf2e5b57&#34;`. See AdminMetaResourceNew for
	* the API documentation to create new file resources.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param BrandingConfig Updated configuration content
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaBrandingConfigSet(BrandingOptions BrandingConfig) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaBrandingConfigSetAsync(BrandingConfig).get();
	}

	/**
	* AdminMetaBuildConfigGetAsync: Get Software Build Role configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return CompletableFuture yielding a ServerConfigOptionsSoftwareBuildRoleFragment
	*/
	public CompletableFuture<ServerConfigOptionsSoftwareBuildRoleFragment> AdminMetaBuildConfigGetAsync()  {
		var resultFuture = new CompletableFuture<ServerConfigOptionsSoftwareBuildRoleFragment>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/build-config/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ServerConfigOptionsSoftwareBuildRoleFragment.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaBuildConfigGet: Get Software Build Role configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return a ServerConfigOptionsSoftwareBuildRoleFragment
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ServerConfigOptionsSoftwareBuildRoleFragment AdminMetaBuildConfigGet() throws ExecutionException, InterruptedException{
		return AdminMetaBuildConfigGetAsync().get();
	}

	/**
	* AdminMetaBuildConfigSetAsync: Set Build Role configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param SoftwareBuildRoleConfig Updated configuration content
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaBuildConfigSetAsync(SoftwareBuildRoleOptions SoftwareBuildRoleConfig) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("SoftwareBuildRoleConfig", CometAPI.getObjectMapper().writeValueAsString(SoftwareBuildRoleConfig));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/build-config/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaBuildConfigSet: Set Build Role configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param SoftwareBuildRoleConfig Updated configuration content
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaBuildConfigSet(SoftwareBuildRoleOptions SoftwareBuildRoleConfig) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaBuildConfigSetAsync(SoftwareBuildRoleConfig).get();
	}

	/**
	* AdminMetaConstellationConfigGetAsync: Get Constellation configuration for the current organization
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @return CompletableFuture yielding a ConstellationRoleOptions
	*/
	public CompletableFuture<ConstellationRoleOptions> AdminMetaConstellationConfigGetAsync()  {
		var resultFuture = new CompletableFuture<ConstellationRoleOptions>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/constellation/config/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ConstellationRoleOptions.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaConstellationConfigGet: Get Constellation configuration for the current organization
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @return a ConstellationRoleOptions
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ConstellationRoleOptions AdminMetaConstellationConfigGet() throws ExecutionException, InterruptedException{
		return AdminMetaConstellationConfigGetAsync().get();
	}

	/**
	* AdminMetaConstellationConfigSetAsync: Set Constellation configuration for the current organization
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @param ConstellationRoleOptions Constellation role options to set
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaConstellationConfigSetAsync(ConstellationRoleOptions ConstellationRoleOptions) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("ConstellationRoleOptions", CometAPI.getObjectMapper().writeValueAsString(ConstellationRoleOptions));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/constellation/config/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaConstellationConfigSet: Set Constellation configuration for the current organization
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Constellation Role to be enabled.
	* @param ConstellationRoleOptions Constellation role options to set
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaConstellationConfigSet(ConstellationRoleOptions ConstellationRoleOptions) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaConstellationConfigSetAsync(ConstellationRoleOptions).get();
	}

	/**
	* AdminMetaEmailOptionsGetAsync: Get the email options
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return CompletableFuture yielding an EmailOptions
	*/
	public CompletableFuture<EmailOptions> AdminMetaEmailOptionsGetAsync()  {
		var resultFuture = new CompletableFuture<EmailOptions>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/email-options/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, EmailOptions.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaEmailOptionsGet: Get the email options
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return an EmailOptions
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public EmailOptions AdminMetaEmailOptionsGet() throws ExecutionException, InterruptedException{
		return AdminMetaEmailOptionsGetAsync().get();
	}

	/**
	* AdminMetaEmailOptionsSetAsync: Set the email options
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param EmailOptions The replacement email reporting options.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaEmailOptionsSetAsync(EmailOptions EmailOptions) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("EmailOptions", CometAPI.getObjectMapper().writeValueAsString(EmailOptions));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/email-options/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaEmailOptionsSet: Set the email options
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param EmailOptions The replacement email reporting options.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaEmailOptionsSet(EmailOptions EmailOptions) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaEmailOptionsSetAsync(EmailOptions).get();
	}

	/**
	* AdminMetaListAvailableLogDaysAsync: Get log files
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return CompletableFuture yielding an int[]
	*/
	public CompletableFuture<int[]> AdminMetaListAvailableLogDaysAsync()  {
		var resultFuture = new CompletableFuture<int[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/list-available-log-days", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, int[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaListAvailableLogDays: Get log files
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return an int[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public int[] AdminMetaListAvailableLogDays() throws ExecutionException, InterruptedException{
		return AdminMetaListAvailableLogDaysAsync().get();
	}

	/**
	* AdminMetaPsaConfigListGetAsync: Get the server PSA configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return CompletableFuture yielding a PSAConfig[]
	*/
	public CompletableFuture<PSAConfig[]> AdminMetaPsaConfigListGetAsync()  {
		var resultFuture = new CompletableFuture<PSAConfig[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/psa-config-list/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, PSAConfig[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaPsaConfigListGet: Get the server PSA configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return a PSAConfig[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public PSAConfig[] AdminMetaPsaConfigListGet() throws ExecutionException, InterruptedException{
		return AdminMetaPsaConfigListGetAsync().get();
	}

	/**
	* AdminMetaPsaConfigListSetAsync: Update the server PSA configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param PSAConfigList The replacement PSA configuration list
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaPsaConfigListSetAsync(PSAConfig[] PSAConfigList) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("PSAConfigList", CometAPI.getObjectMapper().writeValueAsString(PSAConfigList));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/psa-config-list/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaPsaConfigListSet: Update the server PSA configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param PSAConfigList The replacement PSA configuration list
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaPsaConfigListSet(PSAConfig[] PSAConfigList) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaPsaConfigListSetAsync(PSAConfigList).get();
	}

	/**
	* AdminMetaPsaConfigListSyncNowAsync: Synchronize all PSA services now
	* This API applies to the current Organization&#39;s PSAConfig&#39;s only.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaPsaConfigListSyncNowAsync()  {
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/psa-config-list/sync-now", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaPsaConfigListSyncNow: Synchronize all PSA services now
	* This API applies to the current Organization&#39;s PSAConfig&#39;s only.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminMetaPsaConfigListSyncNow() throws ExecutionException, InterruptedException{
		return AdminMetaPsaConfigListSyncNowAsync().get();
	}

	/**
	* AdminMetaReadAllLogsAsync: Get a ZIP file of all of the server&#39;s log files
	* On non-Windows platforms, log content uses LF line endings. On Windows, Comet changed from LF to CRLF line endings in
	* 18.3.2.
	* This API does not automatically convert line endings; around the 18.3.2 timeframe, log content may even contain mixed
	* line-endings.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminMetaReadAllLogsAsync()  {
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/read-all-logs", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaReadAllLogs: Get a ZIP file of all of the server&#39;s log files
	* On non-Windows platforms, log content uses LF line endings. On Windows, Comet changed from LF to CRLF line endings in
	* 18.3.2.
	* This API does not automatically convert line endings; around the 18.3.2 timeframe, log content may even contain mixed
	* line-endings.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminMetaReadAllLogs() throws ExecutionException, InterruptedException{
		return AdminMetaReadAllLogsAsync().get();
	}

	/**
	* AdminMetaReadLogsAsync: Get log file content
	* On non-Windows platforms, log content uses LF line endings. On Windows, Comet changed from LF to CRLF line endings in
	* 18.3.2.
	* This API does not automatically convert line endings; around the 18.3.2 timeframe, log content may even contain mixed
	* line-endings.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param Log A log day, selected from the options returned by the Get Log Files API
	* @return CompletableFuture yielding a byte[]
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<byte[]> AdminMetaReadLogsAsync(Integer Log) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Log", CometAPI.getObjectMapper().writeValueAsString(Log));
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/read-logs", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaReadLogs: Get log file content
	* On non-Windows platforms, log content uses LF line endings. On Windows, Comet changed from LF to CRLF line endings in
	* 18.3.2.
	* This API does not automatically convert line endings; around the 18.3.2 timeframe, log content may even contain mixed
	* line-endings.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param Log A log day, selected from the options returned by the Get Log Files API
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public byte[] AdminMetaReadLogs(Integer Log) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaReadLogsAsync(Log).get();
	}

	/**
	* AdminMetaReadSelectLogsAsync: Get logs file content
	* On non-Windows platforms, log content uses LF line endings. On Windows, Comet changed from LF to CRLF line endings in
	* 18.3.2.
	* This API does not automatically convert line endings; around the 18.3.2 timeframe, log content may even contain mixed
	* line-endings.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param Logs An array of log days, selected from the options returned by the Get Log Files API
	* @return CompletableFuture yielding a byte[]
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<byte[]> AdminMetaReadSelectLogsAsync(int[] Logs) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Logs", CometAPI.getObjectMapper().writeValueAsString(Logs));
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/read-select-logs", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaReadSelectLogs: Get logs file content
	* On non-Windows platforms, log content uses LF line endings. On Windows, Comet changed from LF to CRLF line endings in
	* 18.3.2.
	* This API does not automatically convert line endings; around the 18.3.2 timeframe, log content may even contain mixed
	* line-endings.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param Logs An array of log days, selected from the options returned by the Get Log Files API
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public byte[] AdminMetaReadSelectLogs(int[] Logs) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaReadSelectLogsAsync(Logs).get();
	}

	/**
	* AdminMetaRemoteStorageVaultGetAsync: Get Requesting Remote Storage Vault Config
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return CompletableFuture yielding a RemoteStorageOption[]
	*/
	public CompletableFuture<RemoteStorageOption[]> AdminMetaRemoteStorageVaultGetAsync()  {
		var resultFuture = new CompletableFuture<RemoteStorageOption[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/remote-storage-vault/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, RemoteStorageOption[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaRemoteStorageVaultGet: Get Requesting Remote Storage Vault Config
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return a RemoteStorageOption[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public RemoteStorageOption[] AdminMetaRemoteStorageVaultGet() throws ExecutionException, InterruptedException{
		return AdminMetaRemoteStorageVaultGetAsync().get();
	}

	/**
	* AdminMetaRemoteStorageVaultSetAsync: Set Storage template vault options
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param RemoteStorageOptions Updated configuration content
	* @param ReplacementAutoVaultID (Optional) Replacement Storage Template ID for auto Storage Vault configurations that
	* use deleted Storage Templates
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaRemoteStorageVaultSetAsync(RemoteStorageOption[] RemoteStorageOptions, String ReplacementAutoVaultID) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("RemoteStorageOptions", CometAPI.getObjectMapper().writeValueAsString(RemoteStorageOptions));
		if (ReplacementAutoVaultID != null) data.put("ReplacementAutoVaultID",  ReplacementAutoVaultID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/remote-storage-vault/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaRemoteStorageVaultSet: Set Storage template vault options
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param RemoteStorageOptions Updated configuration content
	* @param ReplacementAutoVaultID (Optional) Replacement Storage Template ID for auto Storage Vault configurations that
	* use deleted Storage Templates
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaRemoteStorageVaultSet(RemoteStorageOption[] RemoteStorageOptions, String ReplacementAutoVaultID) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaRemoteStorageVaultSetAsync(RemoteStorageOptions, ReplacementAutoVaultID).get();
	}

	/**
	* AdminMetaRemoteStorageVaultTestAsync: Test the connection to the storage template
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param TemplateOptions Storage Template Vault Options
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaRemoteStorageVaultTestAsync(RemoteStorageOption TemplateOptions) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TemplateOptions", CometAPI.getObjectMapper().writeValueAsString(TemplateOptions));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/remote-storage-vault/test", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaRemoteStorageVaultTest: Test the connection to the storage template
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param TemplateOptions Storage Template Vault Options
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaRemoteStorageVaultTest(RemoteStorageOption TemplateOptions) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaRemoteStorageVaultTestAsync(TemplateOptions).get();
	}

	/**
	* AdminMetaResourceGetAsync: Get a resource file
	* Resources are used to upload files within the server configuration.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Hash The resource identifier
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> AdminMetaResourceGetAsync(String Hash)  {
		var data = new HashMap<String,String>();

		data.put("Hash", Hash);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/resource/get", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaResourceGet: Get a resource file
	* Resources are used to upload files within the server configuration.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Hash The resource identifier
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] AdminMetaResourceGet(String Hash) throws ExecutionException, InterruptedException{
		return AdminMetaResourceGetAsync(Hash).get();
	}

	/**
	* AdminMetaResourceNewAsync: Upload a resource file
	* Resources are used to upload files within the server configuration.
	* The resulting resource ID is autogenerated.
	* The lifespan of an uploaded resource is undefined. Resources may be deleted automatically, but it should remain
	* available until the next call to AdminMetaServerConfigSet, and will remain available for as long as it is referenced
	* by the server configuration.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param upload The uploaded file contents, as a multipart/form-data part.
	* @return CompletableFuture yielding an AdminResourceResponse
	*/
	public CompletableFuture<AdminResourceResponse> AdminMetaResourceNewAsync(String upload)  {
		throw new UnsupportedOperationException("Multipart uploads are currently not supported in the SDK");
	}

	/**
	* AdminMetaResourceNew: Upload a resource file
	* Resources are used to upload files within the server configuration.
	* The resulting resource ID is autogenerated.
	* The lifespan of an uploaded resource is undefined. Resources may be deleted automatically, but it should remain
	* available until the next call to AdminMetaServerConfigSet, and will remain available for as long as it is referenced
	* by the server configuration.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param upload The uploaded file contents, as a multipart/form-data part.
	* @return an AdminResourceResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public AdminResourceResponse AdminMetaResourceNew(String upload) throws ExecutionException, InterruptedException{
		return AdminMetaResourceNewAsync(upload).get();
	}

	/**
	* AdminMetaRestartServiceAsync: Restart server
	* The Comet Server process will exit. The service manager should restart the server automatically.
	* 
	* Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it
	* returns a successful response before shutting down.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* Access to this API may be prevented on a per-administrator basis.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaRestartServiceAsync()  {
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/restart-service", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaRestartService: Restart server
	* The Comet Server process will exit. The service manager should restart the server automatically.
	* 
	* Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it
	* returns a successful response before shutting down.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* Access to this API may be prevented on a per-administrator basis.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminMetaRestartService() throws ExecutionException, InterruptedException{
		return AdminMetaRestartServiceAsync().get();
	}

	/**
	* AdminMetaSendTestEmailAsync: Send a test email message
	* This allows the Comet Server web interface to support testing different email credentials during setup.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param EmailOptions Updated configuration content
	* @param Recipient Target email address to send test email
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaSendTestEmailAsync(EmailOptions EmailOptions, String Recipient) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("EmailOptions", CometAPI.getObjectMapper().writeValueAsString(EmailOptions));
		data.put("Recipient", Recipient);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/send-test-email", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaSendTestEmail: Send a test email message
	* This allows the Comet Server web interface to support testing different email credentials during setup.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param EmailOptions Updated configuration content
	* @param Recipient Target email address to send test email
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaSendTestEmail(EmailOptions EmailOptions, String Recipient) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaSendTestEmailAsync(EmailOptions, Recipient).get();
	}

	/**
	* AdminMetaSendTestReportAsync: Send a test admin email report
	* This allows a user to send a test email report
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param EmailReportingOption Test email reporting option for sending
	* @param TargetOrganization (Optional) If present, Testing email with a target organization. Only allowed for top-level
	* admins. (&gt;= 24.3.0)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaSendTestReportAsync(EmailReportingOption EmailReportingOption, String TargetOrganization) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("EmailReportingOption", CometAPI.getObjectMapper().writeValueAsString(EmailReportingOption));
		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/send-test-report", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaSendTestReport: Send a test admin email report
	* This allows a user to send a test email report
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param EmailReportingOption Test email reporting option for sending
	* @param TargetOrganization (Optional) If present, Testing email with a target organization. Only allowed for top-level
	* admins. (&gt;= 24.3.0)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaSendTestReport(EmailReportingOption EmailReportingOption, String TargetOrganization) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaSendTestReportAsync(EmailReportingOption, TargetOrganization).get();
	}

	/**
	* AdminMetaServerConfigGetAsync: Get server configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return CompletableFuture yielding a ServerConfigOptions
	*/
	public CompletableFuture<ServerConfigOptions> AdminMetaServerConfigGetAsync()  {
		var resultFuture = new CompletableFuture<ServerConfigOptions>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/server-config/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ServerConfigOptions.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaServerConfigGet: Get server configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return a ServerConfigOptions
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ServerConfigOptions AdminMetaServerConfigGet() throws ExecutionException, InterruptedException{
		return AdminMetaServerConfigGetAsync().get();
	}

	/**
	* AdminMetaServerConfigNetworkInterfacesAsync: List the available network interfaces on the PC running Comet Server
	* Any IPv6 addresses are listed in compressed form without square-brackets.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return CompletableFuture yielding a String[]
	*/
	public CompletableFuture<String[]> AdminMetaServerConfigNetworkInterfacesAsync()  {
		var resultFuture = new CompletableFuture<String[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/server-config/network-interfaces", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, String[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaServerConfigNetworkInterfaces: List the available network interfaces on the PC running Comet Server
	* Any IPv6 addresses are listed in compressed form without square-brackets.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return a String[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public String[] AdminMetaServerConfigNetworkInterfaces() throws ExecutionException, InterruptedException{
		return AdminMetaServerConfigNetworkInterfacesAsync().get();
	}

	/**
	* AdminMetaServerConfigSetAsync: Set server configuration
	* The Comet Server process will exit. The service manager should restart the server automatically.
	* 
	* Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it
	* returns a successful response before shutting down.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param Config Updated configuration content
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaServerConfigSetAsync(ServerConfigOptions Config) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Config", CometAPI.getObjectMapper().writeValueAsString(Config));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/server-config/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaServerConfigSet: Set server configuration
	* The Comet Server process will exit. The service manager should restart the server automatically.
	* 
	* Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it
	* returns a successful response before shutting down.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param Config Updated configuration content
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaServerConfigSet(ServerConfigOptions Config) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaServerConfigSetAsync(Config).get();
	}

	/**
	* AdminMetaShutdownServiceAsync: Shut down server
	* The Comet Server process will exit.
	* 
	* Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it
	* returns a successful response before shutting down.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* Access to this API may be prevented on a per-administrator basis.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaShutdownServiceAsync()  {
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/shutdown-service", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaShutdownService: Shut down server
	* The Comet Server process will exit.
	* 
	* Prior to 18.9.2, this API terminated the server immediately without returning a response. In 18.9.2 and later, it
	* returns a successful response before shutting down.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* Access to this API may be prevented on a per-administrator basis.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminMetaShutdownService() throws ExecutionException, InterruptedException{
		return AdminMetaShutdownServiceAsync().get();
	}

	/**
	* AdminMetaSoftwareUpdateNewsAsync: Get software update news from the software provider
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return CompletableFuture yielding a SoftwareUpdateNewsResponse
	*/
	public CompletableFuture<SoftwareUpdateNewsResponse> AdminMetaSoftwareUpdateNewsAsync()  {
		var resultFuture = new CompletableFuture<SoftwareUpdateNewsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/software-update-news", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, SoftwareUpdateNewsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaSoftwareUpdateNews: Get software update news from the software provider
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return a SoftwareUpdateNewsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public SoftwareUpdateNewsResponse AdminMetaSoftwareUpdateNews() throws ExecutionException, InterruptedException{
		return AdminMetaSoftwareUpdateNewsAsync().get();
	}

	/**
	* AdminMetaStatsAsync: Get Comet Server historical statistics
	* The returned key-value map is not necessarily ordered. Client-side code should sort the result before display.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Simple Remove redundant statistics
	* @return CompletableFuture yielding a HashMap&lt;Long,StatResult&gt;
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<HashMap<Long,StatResult>> AdminMetaStatsAsync(Boolean Simple) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Simple", CometAPI.getObjectMapper().writeValueAsString(Simple));
		var resultFuture = new CompletableFuture<HashMap<Long,StatResult>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/stats", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, Long.class, StatResult.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaStats: Get Comet Server historical statistics
	* The returned key-value map is not necessarily ordered. Client-side code should sort the result before display.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @param Simple Remove redundant statistics
	* @return a HashMap&lt;Long,StatResult&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public HashMap<Long,StatResult> AdminMetaStats(Boolean Simple) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaStatsAsync(Simple).get();
	}

	/**
	* AdminMetaVersionAsync: Get server properties
	* Retrieve the version number and basic properties about the server.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return CompletableFuture yielding a ServerMetaVersionInfo
	*/
	public CompletableFuture<ServerMetaVersionInfo> AdminMetaVersionAsync()  {
		var resultFuture = new CompletableFuture<ServerMetaVersionInfo>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/version", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ServerMetaVersionInfo.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaVersion: Get server properties
	* Retrieve the version number and basic properties about the server.
	* 
	* You must supply administrator authentication credentials to use this API.
	* @return a ServerMetaVersionInfo
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ServerMetaVersionInfo AdminMetaVersion() throws ExecutionException, InterruptedException{
		return AdminMetaVersionAsync().get();
	}

	/**
	* AdminMetaWebhookOptionsGetAsync: Get the server webhook configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return CompletableFuture yielding a HashMap&lt;String,WebhookOption&gt;
	*/
	public CompletableFuture<HashMap<String,WebhookOption>> AdminMetaWebhookOptionsGetAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,WebhookOption>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/webhook-options/get", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, WebhookOption.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaWebhookOptionsGet: Get the server webhook configuration
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @return a HashMap&lt;String,WebhookOption&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,WebhookOption> AdminMetaWebhookOptionsGet() throws ExecutionException, InterruptedException{
		return AdminMetaWebhookOptionsGetAsync().get();
	}

	/**
	* AdminMetaWebhookOptionsSetAsync: Update the server webhook configuration
	* Calling this endpoint will interrupt any messages currently queued for existing webhook destinations.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param WebhookOptions The replacement webhook target options.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminMetaWebhookOptionsSetAsync(HashMap<String,WebhookOption> WebhookOptions) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("WebhookOptions", CometAPI.getObjectMapper().writeValueAsString(WebhookOptions));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/meta/webhook-options/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminMetaWebhookOptionsSet: Update the server webhook configuration
	* Calling this endpoint will interrupt any messages currently queued for existing webhook destinations.
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* @param WebhookOptions The replacement webhook target options.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminMetaWebhookOptionsSet(HashMap<String,WebhookOption> WebhookOptions) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminMetaWebhookOptionsSetAsync(WebhookOptions).get();
	}

	/**
	* AdminNewsGetAllAsync: Get News entries (Admin)
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a HashMap&lt;String,NewsEntry&gt;
	*/
	public CompletableFuture<HashMap<String,NewsEntry>> AdminNewsGetAllAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,NewsEntry>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/news/get-all", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, NewsEntry.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminNewsGetAll: Get News entries (Admin)
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @return a HashMap&lt;String,NewsEntry&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,NewsEntry> AdminNewsGetAll() throws ExecutionException, InterruptedException{
		return AdminNewsGetAllAsync().get();
	}

	/**
	* AdminNewsRemoveAsync: Remove news item
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param NewsItem Selected news item GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminNewsRemoveAsync(String NewsItem)  {
		var data = new HashMap<String,String>();

		data.put("NewsItem", NewsItem);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/news/remove", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminNewsRemove: Remove news item
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param NewsItem Selected news item GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminNewsRemove(String NewsItem) throws ExecutionException, InterruptedException{
		return AdminNewsRemoveAsync(NewsItem).get();
	}

	/**
	* AdminNewsSubmitAsync: Submit news item
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param NewsContent Content of news item
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminNewsSubmitAsync(String NewsContent)  {
		var data = new HashMap<String,String>();

		data.put("NewsContent", NewsContent);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/news/submit", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminNewsSubmit: Submit news item
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param NewsContent Content of news item
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminNewsSubmit(String NewsContent) throws ExecutionException, InterruptedException{
		return AdminNewsSubmitAsync(NewsContent).get();
	}

	/**
	* AdminOrganizationDeleteAsync: Delete an organization and all related users
	* 
	* Prior to Comet 22.6.0, this API was documented as returning the OrganizationResponse type. However, it always has
	* returned only a CometAPIResponseMessage.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param OrganizationID (Optional) (No description available)
	* @param UninstallConfig (Optional) Uninstall software configuration
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminOrganizationDeleteAsync(String OrganizationID, UninstallConfig UninstallConfig) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		if (OrganizationID != null) data.put("OrganizationID",  OrganizationID);
		if (UninstallConfig != null) data.put("UninstallConfig", CometAPI.getObjectMapper().writeValueAsString(UninstallConfig));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/organization/delete", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminOrganizationDelete: Delete an organization and all related users
	* 
	* Prior to Comet 22.6.0, this API was documented as returning the OrganizationResponse type. However, it always has
	* returned only a CometAPIResponseMessage.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param OrganizationID (Optional) (No description available)
	* @param UninstallConfig (Optional) Uninstall software configuration
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminOrganizationDelete(String OrganizationID, UninstallConfig UninstallConfig) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminOrganizationDeleteAsync(OrganizationID, UninstallConfig).get();
	}

	/**
	* AdminOrganizationExportAsync: Run self-backup for a specific tenant
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param Options The export config options
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminOrganizationExportAsync(SelfBackupExportOptions Options) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Options", CometAPI.getObjectMapper().writeValueAsString(Options));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/organization/export", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminOrganizationExport: Run self-backup for a specific tenant
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param Options The export config options
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminOrganizationExport(SelfBackupExportOptions Options) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminOrganizationExportAsync(Options).get();
	}

	/**
	* AdminOrganizationListAsync: List Organizations
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return CompletableFuture yielding a HashMap&lt;String,Organization&gt;
	*/
	public CompletableFuture<HashMap<String,Organization>> AdminOrganizationListAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,Organization>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/organization/list", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, Organization.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminOrganizationList: List Organizations
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return a HashMap&lt;String,Organization&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,Organization> AdminOrganizationList() throws ExecutionException, InterruptedException{
		return AdminOrganizationListAsync().get();
	}

	/**
	* AdminOrganizationSetAsync: Create or Update an Organization
	* 
	* Prior to Comet 22.6.0, the &#39;ID&#39; and &#39;Organization&#39; fields were not present in the response.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param OrganizationID (Optional) (No description available)
	* @param Organization (Optional) (No description available)
	* @return CompletableFuture yielding an OrganizationResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<OrganizationResponse> AdminOrganizationSetAsync(String OrganizationID, Organization Organization) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		if (OrganizationID != null) data.put("OrganizationID",  OrganizationID);
		if (Organization != null) data.put("Organization", CometAPI.getObjectMapper().writeValueAsString(Organization));
		var resultFuture = new CompletableFuture<OrganizationResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/organization/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, OrganizationResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminOrganizationSet: Create or Update an Organization
	* 
	* Prior to Comet 22.6.0, the &#39;ID&#39; and &#39;Organization&#39; fields were not present in the response.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param OrganizationID (Optional) (No description available)
	* @param Organization (Optional) (No description available)
	* @return an OrganizationResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public OrganizationResponse AdminOrganizationSet(String OrganizationID, Organization Organization) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminOrganizationSetAsync(OrganizationID, Organization).get();
	}

	/**
	* AdminPoliciesDeleteAsync: Delete an existing policy object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param PolicyID The policy ID to update or create
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminPoliciesDeleteAsync(String PolicyID)  {
		var data = new HashMap<String,String>();

		data.put("PolicyID", PolicyID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/policies/delete", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminPoliciesDelete: Delete an existing policy object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param PolicyID The policy ID to update or create
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminPoliciesDelete(String PolicyID) throws ExecutionException, InterruptedException{
		return AdminPoliciesDeleteAsync(PolicyID).get();
	}

	/**
	* AdminPoliciesGetAsync: Retrieve a single policy object
	* A hash is also returned, to allow atomic modification operations.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param PolicyID The policy ID to retrieve
	* @return CompletableFuture yielding a GetGroupPolicyResponse
	*/
	public CompletableFuture<GetGroupPolicyResponse> AdminPoliciesGetAsync(String PolicyID)  {
		var data = new HashMap<String,String>();

		data.put("PolicyID", PolicyID);
		var resultFuture = new CompletableFuture<GetGroupPolicyResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/policies/get", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, GetGroupPolicyResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminPoliciesGet: Retrieve a single policy object
	* A hash is also returned, to allow atomic modification operations.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param PolicyID The policy ID to retrieve
	* @return a GetGroupPolicyResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public GetGroupPolicyResponse AdminPoliciesGet(String PolicyID) throws ExecutionException, InterruptedException{
		return AdminPoliciesGetAsync(PolicyID).get();
	}

	/**
	* AdminPoliciesListAsync: List all policy object names
	* For the top-level organization, the API result includes all policies for all organizations, unless the
	* TargetOrganization parameter is present.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the policies belonging to another organization. Only allowed
	* for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return CompletableFuture yielding a HashMap&lt;String,String&gt;
	*/
	public CompletableFuture<HashMap<String,String>> AdminPoliciesListAsync(String TargetOrganization)  {
		var data = new HashMap<String,String>();

		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<HashMap<String,String>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/policies/list", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, String.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminPoliciesList: List all policy object names
	* For the top-level organization, the API result includes all policies for all organizations, unless the
	* TargetOrganization parameter is present.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the policies belonging to another organization. Only allowed
	* for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return a HashMap&lt;String,String&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,String> AdminPoliciesList(String TargetOrganization) throws ExecutionException, InterruptedException{
		return AdminPoliciesListAsync(TargetOrganization).get();
	}

	/**
	* AdminPoliciesListFullAsync: Get all policy objects
	* For the top-level organization, the API result includes all policies for all organizations, unless the
	* TargetOrganization parameter is present.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the policies belonging to another organization. Only allowed
	* for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return CompletableFuture yielding a HashMap&lt;String,GroupPolicy&gt;
	*/
	public CompletableFuture<HashMap<String,GroupPolicy>> AdminPoliciesListFullAsync(String TargetOrganization)  {
		var data = new HashMap<String,String>();

		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<HashMap<String,GroupPolicy>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/policies/list-full", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, GroupPolicy.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminPoliciesListFull: Get all policy objects
	* For the top-level organization, the API result includes all policies for all organizations, unless the
	* TargetOrganization parameter is present.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the policies belonging to another organization. Only allowed
	* for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return a HashMap&lt;String,GroupPolicy&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,GroupPolicy> AdminPoliciesListFull(String TargetOrganization) throws ExecutionException, InterruptedException{
		return AdminPoliciesListFullAsync(TargetOrganization).get();
	}

	/**
	* AdminPoliciesNewAsync: Create a new policy object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Policy The policy data
	* @return CompletableFuture yielding a CreateGroupPolicyResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CreateGroupPolicyResponse> AdminPoliciesNewAsync(GroupPolicy Policy) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Policy", CometAPI.getObjectMapper().writeValueAsString(Policy));
		var resultFuture = new CompletableFuture<CreateGroupPolicyResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/policies/new", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CreateGroupPolicyResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminPoliciesNew: Create a new policy object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Policy The policy data
	* @return a CreateGroupPolicyResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CreateGroupPolicyResponse AdminPoliciesNew(GroupPolicy Policy) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminPoliciesNewAsync(Policy).get();
	}

	/**
	* AdminPoliciesSetAsync: Update an existing policy object
	* An optional hash may be used, to ensure the modification was atomic.
	* This API can also be used to create a new policy object with a specific hash.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param PolicyID The policy ID to update or create
	* @param Policy The policy data
	* @param CheckPolicyHash (Optional) An atomic verification hash as supplied by the AdminPoliciesGet API
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminPoliciesSetAsync(String PolicyID, GroupPolicy Policy, String CheckPolicyHash) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("PolicyID", PolicyID);
		data.put("Policy", CometAPI.getObjectMapper().writeValueAsString(Policy));
		if (CheckPolicyHash != null) data.put("CheckPolicyHash",  CheckPolicyHash);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/policies/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminPoliciesSet: Update an existing policy object
	* An optional hash may be used, to ensure the modification was atomic.
	* This API can also be used to create a new policy object with a specific hash.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param PolicyID The policy ID to update or create
	* @param Policy The policy data
	* @param CheckPolicyHash (Optional) An atomic verification hash as supplied by the AdminPoliciesGet API
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminPoliciesSet(String PolicyID, GroupPolicy Policy, String CheckPolicyHash) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminPoliciesSetAsync(PolicyID, Policy, CheckPolicyHash).get();
	}

	/**
	* AdminPreviewUserEmailReportAsync: Preview an email report for a customer
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param EmailReportConfig Email report configuration to preview
	* @param EmailAddress (Optional) Email address that may be included in the report body (&gt;= 20.3.3)
	* @return CompletableFuture yielding an EmailReportGeneratedPreview
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<EmailReportGeneratedPreview> AdminPreviewUserEmailReportAsync(String TargetUser, EmailReportConfig EmailReportConfig, String EmailAddress) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("EmailReportConfig", CometAPI.getObjectMapper().writeValueAsString(EmailReportConfig));
		if (EmailAddress != null) data.put("EmailAddress",  EmailAddress);
		var resultFuture = new CompletableFuture<EmailReportGeneratedPreview>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/preview-user-email-report", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, EmailReportGeneratedPreview.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminPreviewUserEmailReport: Preview an email report for a customer
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param EmailReportConfig Email report configuration to preview
	* @param EmailAddress (Optional) Email address that may be included in the report body (&gt;= 20.3.3)
	* @return an EmailReportGeneratedPreview
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public EmailReportGeneratedPreview AdminPreviewUserEmailReport(String TargetUser, EmailReportConfig EmailReportConfig, String EmailAddress) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminPreviewUserEmailReportAsync(TargetUser, EmailReportConfig, EmailAddress).get();
	}

	/**
	* AdminReplicationStateAsync: Get Replication status
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return CompletableFuture yielding a ReplicatorStateAPIResponse[]
	*/
	public CompletableFuture<ReplicatorStateAPIResponse[]> AdminReplicationStateAsync()  {
		var resultFuture = new CompletableFuture<ReplicatorStateAPIResponse[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/replication/state", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ReplicatorStateAPIResponse[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminReplicationState: Get Replication status
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return a ReplicatorStateAPIResponse[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ReplicatorStateAPIResponse[] AdminReplicationState() throws ExecutionException, InterruptedException{
		return AdminReplicationStateAsync().get();
	}

	/**
	* AdminRequestStorageVaultAsync: Request a new Storage Vault on behalf of a user
	* This action does not respect the &#34;Prevent creating new Storage Vaults (via Request)&#34; policy setting. New
	* Storage Vaults can be requested regardless of the policy setting.
	* Prior to Comet 19.8.0, the response type was CometAPIResponseMessage (i.e. no DestinationID field in response).
	* The StorageProvider must exist for the target user account&#39;s organization.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser The user to receive the new Storage Vault
	* @param StorageProvider ID for the storage template destination
	* @param SelfAddress (Optional) The external URL for this server. Used to resolve conflicts
	* @param DeviceID (Optional) The ID of the device to be added as a associated device of the Storage Vault
	* @return CompletableFuture yielding a RequestStorageVaultResponseMessage
	*/
	public CompletableFuture<RequestStorageVaultResponseMessage> AdminRequestStorageVaultAsync(String TargetUser, String StorageProvider, String SelfAddress, String DeviceID)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("StorageProvider", StorageProvider);
		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		if (DeviceID != null) data.put("DeviceID",  DeviceID);
		var resultFuture = new CompletableFuture<RequestStorageVaultResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/request-storage-vault", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, RequestStorageVaultResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminRequestStorageVault: Request a new Storage Vault on behalf of a user
	* This action does not respect the &#34;Prevent creating new Storage Vaults (via Request)&#34; policy setting. New
	* Storage Vaults can be requested regardless of the policy setting.
	* Prior to Comet 19.8.0, the response type was CometAPIResponseMessage (i.e. no DestinationID field in response).
	* The StorageProvider must exist for the target user account&#39;s organization.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser The user to receive the new Storage Vault
	* @param StorageProvider ID for the storage template destination
	* @param SelfAddress (Optional) The external URL for this server. Used to resolve conflicts
	* @param DeviceID (Optional) The ID of the device to be added as a associated device of the Storage Vault
	* @return a RequestStorageVaultResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public RequestStorageVaultResponseMessage AdminRequestStorageVault(String TargetUser, String StorageProvider, String SelfAddress, String DeviceID) throws ExecutionException, InterruptedException{
		return AdminRequestStorageVaultAsync(TargetUser, StorageProvider, SelfAddress, DeviceID).get();
	}

	/**
	* AdminRequestStorageVaultProvidersAsync: Get the available options for Requesting a Storage Vault
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the storage template options belonging to another organization.
	* Only allowed for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return CompletableFuture yielding a HashMap&lt;String,String&gt;
	*/
	public CompletableFuture<HashMap<String,String>> AdminRequestStorageVaultProvidersAsync(String TargetOrganization)  {
		var data = new HashMap<String,String>();

		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<HashMap<String,String>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/request-storage-vault-providers", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, String.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminRequestStorageVaultProviders: Get the available options for Requesting a Storage Vault
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the storage template options belonging to another organization.
	* Only allowed for administrator accounts in the top-level organization. (&gt;= 22.3.7)
	* @return a HashMap&lt;String,String&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,String> AdminRequestStorageVaultProviders(String TargetOrganization) throws ExecutionException, InterruptedException{
		return AdminRequestStorageVaultProvidersAsync(TargetOrganization).get();
	}

	/**
	* AdminResetUserPasswordAsync: Reset user account password
	* The user account must have a recovery code present. A new replacement recovery code will be generated automatically.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param NewPassword New account password
	* @param OldPassword (Optional) Old account password. Required if no recovery code is present for the user account.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminResetUserPasswordAsync(String TargetUser, String NewPassword, String OldPassword)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("NewPassword", NewPassword);
		if (OldPassword != null) data.put("OldPassword",  OldPassword);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/reset-user-password", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminResetUserPassword: Reset user account password
	* The user account must have a recovery code present. A new replacement recovery code will be generated automatically.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param NewPassword New account password
	* @param OldPassword (Optional) Old account password. Required if no recovery code is present for the user account.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminResetUserPassword(String TargetUser, String NewPassword, String OldPassword) throws ExecutionException, InterruptedException{
		return AdminResetUserPasswordAsync(TargetUser, NewPassword, OldPassword).get();
	}

	/**
	* AdminRevokeDeviceAsync: Revoke device from user account
	* It&#39;s possible to simply remove the Device section from the user&#39;s profile, however, using this dedicated API
	* will also gracefully handle live connections.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param TargetDevice Selected Device ID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminRevokeDeviceAsync(String TargetUser, String TargetDevice)  {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("TargetDevice", TargetDevice);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/revoke-device", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminRevokeDevice: Revoke device from user account
	* It&#39;s possible to simply remove the Device section from the user&#39;s profile, however, using this dedicated API
	* will also gracefully handle live connections.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param TargetDevice Selected Device ID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminRevokeDevice(String TargetUser, String TargetDevice) throws ExecutionException, InterruptedException{
		return AdminRevokeDeviceAsync(TargetUser, TargetDevice).get();
	}

	/**
	* AdminSelfBackupStartAsync: Run self-backup on all targets
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminSelfBackupStartAsync()  {
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/self-backup/start", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminSelfBackupStart: Run self-backup on all targets
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminSelfBackupStart() throws ExecutionException, InterruptedException{
		return AdminSelfBackupStartAsync().get();
	}

	/**
	* AdminSetUserProfileAsync: Modify user account profile
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param ProfileData Modified user profile
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminSetUserProfileAsync(String TargetUser, UserProfileConfig ProfileData) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("ProfileData", CometAPI.getObjectMapper().writeValueAsString(ProfileData));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/set-user-profile", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminSetUserProfile: Modify user account profile
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param ProfileData Modified user profile
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminSetUserProfile(String TargetUser, UserProfileConfig ProfileData) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminSetUserProfileAsync(TargetUser, ProfileData).get();
	}

	/**
	* AdminSetUserProfileHashAsync: Modify user account profile (atomic)
	* The hash parameter can be determined from the corresponding API, to atomically ensure that no changes occur between
	* get/set operations.
	* The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve
	* current hash values.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param ProfileData Modified user profile
	* @param RequireHash Previous hash parameter
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminSetUserProfileHashAsync(String TargetUser, UserProfileConfig ProfileData, String RequireHash) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetUser", TargetUser);
		data.put("ProfileData", CometAPI.getObjectMapper().writeValueAsString(ProfileData));
		data.put("RequireHash", RequireHash);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/set-user-profile-hash", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminSetUserProfileHash: Modify user account profile (atomic)
	* The hash parameter can be determined from the corresponding API, to atomically ensure that no changes occur between
	* get/set operations.
	* The hash format is not publicly documented and may change in a future server version. Use server APIs to retrieve
	* current hash values.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetUser Selected account username
	* @param ProfileData Modified user profile
	* @param RequireHash Previous hash parameter
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminSetUserProfileHash(String TargetUser, UserProfileConfig ProfileData, String RequireHash) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminSetUserProfileHashAsync(TargetUser, ProfileData, RequireHash).get();
	}

	/**
	* AdminStorageBucketPropertiesAsync: Retrieve properties for a single bucket
	* This API can also be used to refresh the size measurement for a single bucket by passing a valid AfterTimestamp
	* parameter.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Storage Role to be enabled.
	* @param BucketID Bucket ID
	* @param AfterTimestamp (Optional) Allow a stale size measurement if it is at least as new as the supplied Unix
	* timestamp. Timestamps in the future may produce a result clamped down to the Comet Server&#39;s current time. If not
	* present, the size measurement may be arbitrarily stale.
	* @return CompletableFuture yielding a BucketProperties
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BucketProperties> AdminStorageBucketPropertiesAsync(String BucketID, Integer AfterTimestamp) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("BucketID", BucketID);
		if (AfterTimestamp != null) data.put("AfterTimestamp", CometAPI.getObjectMapper().writeValueAsString(AfterTimestamp));
		var resultFuture = new CompletableFuture<BucketProperties>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/storage/bucket-properties", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BucketProperties.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminStorageBucketProperties: Retrieve properties for a single bucket
	* This API can also be used to refresh the size measurement for a single bucket by passing a valid AfterTimestamp
	* parameter.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Storage Role to be enabled.
	* @param BucketID Bucket ID
	* @param AfterTimestamp (Optional) Allow a stale size measurement if it is at least as new as the supplied Unix
	* timestamp. Timestamps in the future may produce a result clamped down to the Comet Server&#39;s current time. If not
	* present, the size measurement may be arbitrarily stale.
	* @return a BucketProperties
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BucketProperties AdminStorageBucketProperties(String BucketID, Integer AfterTimestamp) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminStorageBucketPropertiesAsync(BucketID, AfterTimestamp).get();
	}

	/**
	* AdminStorageDeleteBucketAsync: Delete a bucket
	* All data will be removed from the server. Misuse can cause data loss!
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Storage Role to be enabled.
	* @param BucketID Selected bucket name
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminStorageDeleteBucketAsync(String BucketID)  {
		var data = new HashMap<String,String>();

		data.put("BucketID", BucketID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/storage/delete-bucket", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminStorageDeleteBucket: Delete a bucket
	* All data will be removed from the server. Misuse can cause data loss!
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Storage Role to be enabled.
	* @param BucketID Selected bucket name
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminStorageDeleteBucket(String BucketID) throws ExecutionException, InterruptedException{
		return AdminStorageDeleteBucketAsync(BucketID).get();
	}

	/**
	* AdminStorageFreeSpaceAsync: Retrieve available space metrics
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API requires the Storage Role to be enabled.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param BucketID (Optional) (This parameter is not used)
	* @return CompletableFuture yielding a StorageFreeSpaceInfo
	*/
	public CompletableFuture<StorageFreeSpaceInfo> AdminStorageFreeSpaceAsync(String BucketID)  {
		var data = new HashMap<String,String>();

		if (BucketID != null) data.put("BucketID",  BucketID);
		var resultFuture = new CompletableFuture<StorageFreeSpaceInfo>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/storage/free-space", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, StorageFreeSpaceInfo.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminStorageFreeSpace: Retrieve available space metrics
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API requires the Storage Role to be enabled.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param BucketID (Optional) (This parameter is not used)
	* @return a StorageFreeSpaceInfo
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public StorageFreeSpaceInfo AdminStorageFreeSpace(String BucketID) throws ExecutionException, InterruptedException{
		return AdminStorageFreeSpaceAsync(BucketID).get();
	}

	/**
	* AdminStorageListBucketsAsync: List all buckets
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Storage Role to be enabled.
	* @return CompletableFuture yielding a HashMap&lt;String,BucketProperties&gt;
	*/
	public CompletableFuture<HashMap<String,BucketProperties>> AdminStorageListBucketsAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,BucketProperties>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/storage/list-buckets", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, BucketProperties.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminStorageListBuckets: List all buckets
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Storage Role to be enabled.
	* @return a HashMap&lt;String,BucketProperties&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,BucketProperties> AdminStorageListBuckets() throws ExecutionException, InterruptedException{
		return AdminStorageListBucketsAsync().get();
	}

	/**
	* AdminStoragePingDestinationAsync: Ping a storage destination
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param ExtraData The destination location settings
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminStoragePingDestinationAsync(DestinationLocation ExtraData) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("ExtraData", CometAPI.getObjectMapper().writeValueAsString(ExtraData));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/storage/ping-destination", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminStoragePingDestination: Ping a storage destination
	* 
	* You must supply administrator authentication credentials to use this API.
	* Access to this API may be prevented on a per-administrator basis.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* @param ExtraData The destination location settings
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminStoragePingDestination(DestinationLocation ExtraData) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminStoragePingDestinationAsync(ExtraData).get();
	}

	/**
	* AdminStorageRegisterBucketAsync: Create a new bucket
	* Leave the Set* parameters blank to generate a bucket with random credentials, or, supply a pre-hashed password for
	* zero-knowledge operations.
	* Any auto-generated credentials are returned in the response message.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Storage Role to be enabled.
	* @param SetBucketValue (Optional) Bucket ID
	* @param SetKeyHashFormat (Optional) Bucket key hashing format
	* @param SetKeyHashValue (Optional) Bucket key hash
	* @param SetOrganizationID (Optional) Target organization ID (&gt;= 20.9.0)
	* @return CompletableFuture yielding an AddBucketResponseMessage
	*/
	public CompletableFuture<AddBucketResponseMessage> AdminStorageRegisterBucketAsync(String SetBucketValue, String SetKeyHashFormat, String SetKeyHashValue, String SetOrganizationID)  {
		var data = new HashMap<String,String>();

		if (SetBucketValue != null) data.put("SetBucketValue",  SetBucketValue);
		if (SetKeyHashFormat != null) data.put("SetKeyHashFormat",  SetKeyHashFormat);
		if (SetKeyHashValue != null) data.put("SetKeyHashValue",  SetKeyHashValue);
		if (SetOrganizationID != null) data.put("SetOrganizationID",  SetOrganizationID);
		var resultFuture = new CompletableFuture<AddBucketResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/storage/register-bucket", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, AddBucketResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminStorageRegisterBucket: Create a new bucket
	* Leave the Set* parameters blank to generate a bucket with random credentials, or, supply a pre-hashed password for
	* zero-knowledge operations.
	* Any auto-generated credentials are returned in the response message.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Storage Role to be enabled.
	* @param SetBucketValue (Optional) Bucket ID
	* @param SetKeyHashFormat (Optional) Bucket key hashing format
	* @param SetKeyHashValue (Optional) Bucket key hash
	* @param SetOrganizationID (Optional) Target organization ID (&gt;= 20.9.0)
	* @return an AddBucketResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public AddBucketResponseMessage AdminStorageRegisterBucket(String SetBucketValue, String SetKeyHashFormat, String SetKeyHashValue, String SetOrganizationID) throws ExecutionException, InterruptedException{
		return AdminStorageRegisterBucketAsync(SetBucketValue, SetKeyHashFormat, SetKeyHashValue, SetOrganizationID).get();
	}

	/**
	* AdminUpdateCampaignStartAsync: Start a new software update campaign
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param Options Configure targets for the software update campaign
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminUpdateCampaignStartAsync(UpdateCampaignOptions Options) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("Options", CometAPI.getObjectMapper().writeValueAsString(Options));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/update-campaign/start", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUpdateCampaignStart: Start a new software update campaign
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @param Options Configure targets for the software update campaign
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminUpdateCampaignStart(UpdateCampaignOptions Options) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminUpdateCampaignStartAsync(Options).get();
	}

	/**
	* AdminUpdateCampaignStatusAsync: Get current campaign status
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding an UpdateCampaignStatus
	*/
	public CompletableFuture<UpdateCampaignStatus> AdminUpdateCampaignStatusAsync()  {
		var resultFuture = new CompletableFuture<UpdateCampaignStatus>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/update-campaign/status", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, UpdateCampaignStatus.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUpdateCampaignStatus: Get current campaign status
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API is only available for top-level administrator accounts, not for Tenant administrator accounts.
	* This API requires the Software Build Role to be enabled.
	* This API requires the Auth Role to be enabled.
	* @return an UpdateCampaignStatus
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public UpdateCampaignStatus AdminUpdateCampaignStatus() throws ExecutionException, InterruptedException{
		return AdminUpdateCampaignStatusAsync().get();
	}

	/**
	* AdminUserGroupsDeleteAsync: Delete an existing user group object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param GroupID The user group ID to delete
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminUserGroupsDeleteAsync(String GroupID)  {
		var data = new HashMap<String,String>();

		data.put("GroupID", GroupID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/user-groups/delete", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUserGroupsDelete: Delete an existing user group object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param GroupID The user group ID to delete
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage AdminUserGroupsDelete(String GroupID) throws ExecutionException, InterruptedException{
		return AdminUserGroupsDeleteAsync(GroupID).get();
	}

	/**
	* AdminUserGroupsGetAsync: Retrieve a single user group object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param GroupID The user group ID to retrieve
	* @param IncludeUsers (Optional) If present, includes the users array in the response.
	* @return CompletableFuture yielding a GetUserGroupWithUsersResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<GetUserGroupWithUsersResponse> AdminUserGroupsGetAsync(String GroupID, Boolean IncludeUsers) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("GroupID", GroupID);
		if (IncludeUsers != null) data.put("IncludeUsers", CometAPI.getObjectMapper().writeValueAsString(IncludeUsers));
		var resultFuture = new CompletableFuture<GetUserGroupWithUsersResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/user-groups/get", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, GetUserGroupWithUsersResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUserGroupsGet: Retrieve a single user group object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param GroupID The user group ID to retrieve
	* @param IncludeUsers (Optional) If present, includes the users array in the response.
	* @return a GetUserGroupWithUsersResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public GetUserGroupWithUsersResponse AdminUserGroupsGet(String GroupID, Boolean IncludeUsers) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminUserGroupsGetAsync(GroupID, IncludeUsers).get();
	}

	/**
	* AdminUserGroupsListAsync: List all user group names
	* For the top-level organization, the API result includes all user groups for all organizations, unless the
	* TargetOrganization parameter is present.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the user groups belonging to another organization. Only allowed
	* for administrator accounts in the top-level organization.
	* @return CompletableFuture yielding a HashMap&lt;String,String&gt;
	*/
	public CompletableFuture<HashMap<String,String>> AdminUserGroupsListAsync(String TargetOrganization)  {
		var data = new HashMap<String,String>();

		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<HashMap<String,String>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/user-groups/list", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, String.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUserGroupsList: List all user group names
	* For the top-level organization, the API result includes all user groups for all organizations, unless the
	* TargetOrganization parameter is present.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the user groups belonging to another organization. Only allowed
	* for administrator accounts in the top-level organization.
	* @return a HashMap&lt;String,String&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,String> AdminUserGroupsList(String TargetOrganization) throws ExecutionException, InterruptedException{
		return AdminUserGroupsListAsync(TargetOrganization).get();
	}

	/**
	* AdminUserGroupsListFullAsync: Get all user group objects
	* For the top-level organization, the API result includes all user groups for all organizations, unless the
	* TargetOrganization parameter is present.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the user groups belonging to the specified organization. Only
	* allowed for administrator accounts in the top-level organization.
	* @return CompletableFuture yielding a HashMap&lt;String,UserGroup&gt;
	*/
	public CompletableFuture<HashMap<String,UserGroup>> AdminUserGroupsListFullAsync(String TargetOrganization)  {
		var data = new HashMap<String,String>();

		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<HashMap<String,UserGroup>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/user-groups/list-full", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, UserGroup.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUserGroupsListFull: Get all user group objects
	* For the top-level organization, the API result includes all user groups for all organizations, unless the
	* TargetOrganization parameter is present.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param TargetOrganization (Optional) If present, list the user groups belonging to the specified organization. Only
	* allowed for administrator accounts in the top-level organization.
	* @return a HashMap&lt;String,UserGroup&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,UserGroup> AdminUserGroupsListFull(String TargetOrganization) throws ExecutionException, InterruptedException{
		return AdminUserGroupsListFullAsync(TargetOrganization).get();
	}

	/**
	* AdminUserGroupsNewAsync: Create a new user group object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Name this is the name of the group.
	* @param TargetOrganization (Optional) If present, list the policies belonging to another organization. Only allowed
	* for administrator accounts in the top-level organization.
	* @return CompletableFuture yielding a CreateUserGroupResponse
	*/
	public CompletableFuture<CreateUserGroupResponse> AdminUserGroupsNewAsync(String Name, String TargetOrganization)  {
		var data = new HashMap<String,String>();

		data.put("Name", Name);
		if (TargetOrganization != null) data.put("TargetOrganization",  TargetOrganization);
		var resultFuture = new CompletableFuture<CreateUserGroupResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/user-groups/new", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CreateUserGroupResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUserGroupsNew: Create a new user group object
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param Name this is the name of the group.
	* @param TargetOrganization (Optional) If present, list the policies belonging to another organization. Only allowed
	* for administrator accounts in the top-level organization.
	* @return a CreateUserGroupResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CreateUserGroupResponse AdminUserGroupsNew(String Name, String TargetOrganization) throws ExecutionException, InterruptedException{
		return AdminUserGroupsNewAsync(Name, TargetOrganization).get();
	}

	/**
	* AdminUserGroupsSetAsync: Update an existing user group or create a new user group
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param GroupID The user group ID to update or create
	* @param Group The user group data
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminUserGroupsSetAsync(String GroupID, UserGroup Group) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("GroupID", GroupID);
		data.put("Group", CometAPI.getObjectMapper().writeValueAsString(Group));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/user-groups/set", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUserGroupsSet: Update an existing user group or create a new user group
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param GroupID The user group ID to update or create
	* @param Group The user group data
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminUserGroupsSet(String GroupID, UserGroup Group) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminUserGroupsSetAsync(GroupID, Group).get();
	}

	/**
	* AdminUserGroupsSetUsersForGroupAsync: Update the users in the specified group
	* The provided list of users will be moved into the specified group, and any users
	* already in the group who are not in the list of usernames will be removed.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param GroupID The user group ID to update
	* @param Users An array of usernames.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> AdminUserGroupsSetUsersForGroupAsync(String GroupID, String[] Users) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("GroupID", GroupID);
		data.put("Users", CometAPI.getObjectMapper().writeValueAsString(Users));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/admin/user-groups/set-users-for-group", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* AdminUserGroupsSetUsersForGroup: Update the users in the specified group
	* The provided list of users will be moved into the specified group, and any users
	* already in the group who are not in the list of usernames will be removed.
	* 
	* You must supply administrator authentication credentials to use this API.
	* This API requires the Auth Role to be enabled.
	* @param GroupID The user group ID to update
	* @param Users An array of usernames.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage AdminUserGroupsSetUsersForGroup(String GroupID, String[] Users) throws ExecutionException, InterruptedException, JsonProcessingException{
		return AdminUserGroupsSetUsersForGroupAsync(GroupID, Users).get();
	}

	/**
	* BrandingPropsAsync: Retrieve basic information about this Comet Server
	* @return CompletableFuture yielding a ServerMetaBrandingProperties
	*/
	public CompletableFuture<ServerMetaBrandingProperties> BrandingPropsAsync()  {
		var resultFuture = new CompletableFuture<ServerMetaBrandingProperties>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "GET", "/gen/branding.props", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, ServerMetaBrandingProperties.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* BrandingProps: Retrieve basic information about this Comet Server
	* @return a ServerMetaBrandingProperties
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public ServerMetaBrandingProperties BrandingProps() throws ExecutionException, InterruptedException{
		return BrandingPropsAsync().get();
	}

	/**
	* HybridSessionStartAsync: Generate a session key (log in)
	* This hybrid API allows you to log in to the Comet Server as either an administrator or end-user account.
	* This API behaves like either AdminAccountSessionStart or UserWebSessionStart, depending on what the supplied
	* credentials were valid for.
	* @return CompletableFuture yielding a SessionKeyRegeneratedResponse
	*/
	public CompletableFuture<SessionKeyRegeneratedResponse> HybridSessionStartAsync()  {
		var resultFuture = new CompletableFuture<SessionKeyRegeneratedResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/hybrid/session/start", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, SessionKeyRegeneratedResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* HybridSessionStart: Generate a session key (log in)
	* This hybrid API allows you to log in to the Comet Server as either an administrator or end-user account.
	* This API behaves like either AdminAccountSessionStart or UserWebSessionStart, depending on what the supplied
	* credentials were valid for.
	* @return a SessionKeyRegeneratedResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public SessionKeyRegeneratedResponse HybridSessionStart() throws ExecutionException, InterruptedException{
		return HybridSessionStartAsync().get();
	}

	/**
	* UserDispatcherEmailPreviewAsync: Request HTML content of an email
	* The remote device must have given consent for an MSP to browse their mail
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Snapshot where the email belongs to
	* @param Destination The Storage Vault ID
	* @param Path of the email to view
	* @return CompletableFuture yielding an EmailReportGeneratedPreview
	*/
	public CompletableFuture<EmailReportGeneratedPreview> UserDispatcherEmailPreviewAsync(String TargetID, String Snapshot, String Destination, String Path)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Snapshot", Snapshot);
		data.put("Destination", Destination);
		data.put("Path", Path);
		var resultFuture = new CompletableFuture<EmailReportGeneratedPreview>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/dispatcher/email-preview", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, EmailReportGeneratedPreview.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserDispatcherEmailPreview: Request HTML content of an email
	* The remote device must have given consent for an MSP to browse their mail
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Snapshot where the email belongs to
	* @param Destination The Storage Vault ID
	* @param Path of the email to view
	* @return an EmailReportGeneratedPreview
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public EmailReportGeneratedPreview UserDispatcherEmailPreview(String TargetID, String Snapshot, String Destination, String Path) throws ExecutionException, InterruptedException{
		return UserDispatcherEmailPreviewAsync(TargetID, Snapshot, Destination, Path).get();
	}

	/**
	* UserWebAccountRegenerateTotpAsync: Generate a new TOTP secret for user (web)
	* The secret is returned as a `data-uri` image of a QR code. The new secret is immediately applied to the current admin
	* account.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param ProfileHash Previous account profile hash
	* @return CompletableFuture yielding a TotpRegeneratedResponse
	*/
	public CompletableFuture<TotpRegeneratedResponse> UserWebAccountRegenerateTotpAsync(String ProfileHash)  {
		var data = new HashMap<String,String>();

		data.put("ProfileHash", ProfileHash);
		var resultFuture = new CompletableFuture<TotpRegeneratedResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/account/regenerate-totp", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, TotpRegeneratedResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebAccountRegenerateTotp: Generate a new TOTP secret for user (web)
	* The secret is returned as a `data-uri` image of a QR code. The new secret is immediately applied to the current admin
	* account.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param ProfileHash Previous account profile hash
	* @return a TotpRegeneratedResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public TotpRegeneratedResponse UserWebAccountRegenerateTotp(String ProfileHash) throws ExecutionException, InterruptedException{
		return UserWebAccountRegenerateTotpAsync(ProfileHash).get();
	}

	/**
	* UserWebAccountResetPasswordAsync: Reset the password for your own user account (web)
	* A new replacement recovery code will be generated if the present recovery code is not empty
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param ProfileHash Previous account profile hash
	* @param OldPassword Current account password
	* @param NewPassword New account password
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebAccountResetPasswordAsync(String ProfileHash, String OldPassword, String NewPassword)  {
		var data = new HashMap<String,String>();

		data.put("ProfileHash", ProfileHash);
		data.put("OldPassword", OldPassword);
		data.put("NewPassword", NewPassword);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/account/reset-password", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebAccountResetPassword: Reset the password for your own user account (web)
	* A new replacement recovery code will be generated if the present recovery code is not empty
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param ProfileHash Previous account profile hash
	* @param OldPassword Current account password
	* @param NewPassword New account password
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage UserWebAccountResetPassword(String ProfileHash, String OldPassword, String NewPassword) throws ExecutionException, InterruptedException{
		return UserWebAccountResetPasswordAsync(ProfileHash, OldPassword, NewPassword).get();
	}

	/**
	* UserWebAccountValidateTotpAsync: Validate the TOTP code before turning 2fa(TOTP) on
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param ProfileHash Previous account profile hash
	* @param TOTPCode Six-digit code after scanning barcode image
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebAccountValidateTotpAsync(String ProfileHash, String TOTPCode)  {
		var data = new HashMap<String,String>();

		data.put("ProfileHash", ProfileHash);
		data.put("TOTPCode", TOTPCode);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/account/validate-totp", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebAccountValidateTotp: Validate the TOTP code before turning 2fa(TOTP) on
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param ProfileHash Previous account profile hash
	* @param TOTPCode Six-digit code after scanning barcode image
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage UserWebAccountValidateTotp(String ProfileHash, String TOTPCode) throws ExecutionException, InterruptedException{
		return UserWebAccountValidateTotpAsync(ProfileHash, TOTPCode).get();
	}

	/**
	* UserWebDispatcherDeleteSnapshotAsync: Instruct a live connected device to delete a stored snapshot
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotID The backup job snapshot ID to delete
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebDispatcherDeleteSnapshotAsync(String TargetID, String DestinationID, String SnapshotID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("DestinationID", DestinationID);
		data.put("SnapshotID", SnapshotID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/delete-snapshot", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherDeleteSnapshot: Instruct a live connected device to delete a stored snapshot
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotID The backup job snapshot ID to delete
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage UserWebDispatcherDeleteSnapshot(String TargetID, String DestinationID, String SnapshotID) throws ExecutionException, InterruptedException{
		return UserWebDispatcherDeleteSnapshotAsync(TargetID, DestinationID, SnapshotID).get();
	}

	/**
	* UserWebDispatcherDeleteSnapshotsAsync: Instruct a live connected device to delete multiple stored snapshots
	* The target device must be running Comet 20.9.10 or later.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotIDs The backup job snapshot IDs to delete
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebDispatcherDeleteSnapshotsAsync(String TargetID, String DestinationID, String[] SnapshotIDs) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("DestinationID", DestinationID);
		data.put("SnapshotIDs", CometAPI.getObjectMapper().writeValueAsString(SnapshotIDs));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/delete-snapshots", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherDeleteSnapshots: Instruct a live connected device to delete multiple stored snapshots
	* The target device must be running Comet 20.9.10 or later.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotIDs The backup job snapshot IDs to delete
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage UserWebDispatcherDeleteSnapshots(String TargetID, String DestinationID, String[] SnapshotIDs) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherDeleteSnapshotsAsync(TargetID, DestinationID, SnapshotIDs).get();
	}

	/**
	* UserWebDispatcherListActiveAsync: List live connected devices in my account
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a HashMap&lt;String,LiveUserConnection&gt;
	*/
	public CompletableFuture<HashMap<String,LiveUserConnection>> UserWebDispatcherListActiveAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,LiveUserConnection>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/list-active", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, LiveUserConnection.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherListActive: List live connected devices in my account
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return a HashMap&lt;String,LiveUserConnection&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,LiveUserConnection> UserWebDispatcherListActive() throws ExecutionException, InterruptedException{
		return UserWebDispatcherListActiveAsync().get();
	}

	/**
	* UserWebDispatcherOffice365ListVirtualAccountsAsync: Request a list of Office365 Resources (groups, sites, teams
	* groups and users)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return CompletableFuture yielding a BrowseOffice365ListVirtualAccountsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseOffice365ListVirtualAccountsResponse> UserWebDispatcherOffice365ListVirtualAccountsAsync(String TargetID, Office365Credential Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseOffice365ListVirtualAccountsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/office365-list-virtual-accounts", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseOffice365ListVirtualAccountsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherOffice365ListVirtualAccounts: Request a list of Office365 Resources (groups, sites, teams groups and
	* users)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return a BrowseOffice365ListVirtualAccountsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseOffice365ListVirtualAccountsResponse UserWebDispatcherOffice365ListVirtualAccounts(String TargetID, Office365Credential Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherOffice365ListVirtualAccountsAsync(TargetID, Credentials).get();
	}

	/**
	* UserWebDispatcherPingDestinationAsync: Test the connection to the storage bucket
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param ExtraData The destination location settings
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebDispatcherPingDestinationAsync(String TargetID, DestinationLocation ExtraData) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("ExtraData", CometAPI.getObjectMapper().writeValueAsString(ExtraData));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/ping-destination", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherPingDestination: Test the connection to the storage bucket
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param ExtraData The destination location settings
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage UserWebDispatcherPingDestination(String TargetID, DestinationLocation ExtraData) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherPingDestinationAsync(TargetID, ExtraData).get();
	}

	/**
	* UserWebDispatcherRegisterOfficeApplicationBeginAsync: Begin the process of registering a new Azure AD application
	* that can access Office 365 for backup
	* After calling this API, you should supply the login details to the end-user, and then begin polling the
	* AdminDispatcherRegisterOfficeApplicationCheck with the supplied &#34;Continuation&#34; parameter to check on the
	* registration process.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param EmailAddress The email address of the Azure AD administrator
	* @return CompletableFuture yielding a RegisterOfficeApplicationBeginResponse
	*/
	public CompletableFuture<RegisterOfficeApplicationBeginResponse> UserWebDispatcherRegisterOfficeApplicationBeginAsync(String TargetID, String EmailAddress)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("EmailAddress", EmailAddress);
		var resultFuture = new CompletableFuture<RegisterOfficeApplicationBeginResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/register-office-application/begin", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, RegisterOfficeApplicationBeginResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRegisterOfficeApplicationBegin: Begin the process of registering a new Azure AD application that can
	* access Office 365 for backup
	* After calling this API, you should supply the login details to the end-user, and then begin polling the
	* AdminDispatcherRegisterOfficeApplicationCheck with the supplied &#34;Continuation&#34; parameter to check on the
	* registration process.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param EmailAddress The email address of the Azure AD administrator
	* @return a RegisterOfficeApplicationBeginResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public RegisterOfficeApplicationBeginResponse UserWebDispatcherRegisterOfficeApplicationBegin(String TargetID, String EmailAddress) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRegisterOfficeApplicationBeginAsync(TargetID, EmailAddress).get();
	}

	/**
	* UserWebDispatcherRegisterOfficeApplicationCheckAsync: Check the process of registering a new Azure AD application
	* that can access Office 365 for backup
	* You should begin the process by calling AdminDispatcherRegisterOfficeApplicationBegin and asking the end-user to
	* complete the Azure authentication steps.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Continuation The ID returned from the AdminDispatcherRegisterOfficeApplicationBegin endpoint
	* @return CompletableFuture yielding a RegisterOfficeApplicationCheckResponse
	*/
	public CompletableFuture<RegisterOfficeApplicationCheckResponse> UserWebDispatcherRegisterOfficeApplicationCheckAsync(String TargetID, String Continuation)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Continuation", Continuation);
		var resultFuture = new CompletableFuture<RegisterOfficeApplicationCheckResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/register-office-application/check", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, RegisterOfficeApplicationCheckResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRegisterOfficeApplicationCheck: Check the process of registering a new Azure AD application that can
	* access Office 365 for backup
	* You should begin the process by calling AdminDispatcherRegisterOfficeApplicationBegin and asking the end-user to
	* complete the Azure authentication steps.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Continuation The ID returned from the AdminDispatcherRegisterOfficeApplicationBegin endpoint
	* @return a RegisterOfficeApplicationCheckResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public RegisterOfficeApplicationCheckResponse UserWebDispatcherRegisterOfficeApplicationCheck(String TargetID, String Continuation) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRegisterOfficeApplicationCheckAsync(TargetID, Continuation).get();
	}

	/**
	* UserWebDispatcherRequestBrowseDiskDrivesAsync: Request a list of physical disk drive information from a live
	* connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a BrowseDiskDrivesResponse
	*/
	public CompletableFuture<BrowseDiskDrivesResponse> UserWebDispatcherRequestBrowseDiskDrivesAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<BrowseDiskDrivesResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-browse-disk-drives", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseDiskDrivesResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestBrowseDiskDrives: Request a list of physical disk drive information from a live connected
	* device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a BrowseDiskDrivesResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BrowseDiskDrivesResponse UserWebDispatcherRequestBrowseDiskDrives(String TargetID) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRequestBrowseDiskDrivesAsync(TargetID).get();
	}

	/**
	* UserWebDispatcherRequestBrowseExchangeEdbAsync: Request a list of Exchange EDB databases from a live connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a BrowseEDBResponse
	*/
	public CompletableFuture<BrowseEDBResponse> UserWebDispatcherRequestBrowseExchangeEdbAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<BrowseEDBResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-browse-exchange-edb", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseEDBResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestBrowseExchangeEdb: Request a list of Exchange EDB databases from a live connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a BrowseEDBResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BrowseEDBResponse UserWebDispatcherRequestBrowseExchangeEdb(String TargetID) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRequestBrowseExchangeEdbAsync(TargetID).get();
	}

	/**
	* UserWebDispatcherRequestBrowseHypervAsync: Request a list of Hyper-V virtual machines from a live connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a BrowseHVResponse
	*/
	public CompletableFuture<BrowseHVResponse> UserWebDispatcherRequestBrowseHypervAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<BrowseHVResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-browse-hyperv", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseHVResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestBrowseHyperv: Request a list of Hyper-V virtual machines from a live connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a BrowseHVResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BrowseHVResponse UserWebDispatcherRequestBrowseHyperv(String TargetID) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRequestBrowseHypervAsync(TargetID).get();
	}

	/**
	* UserWebDispatcherRequestBrowseMongodbAsync: Request a list of tables in MongoDB database
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MongoDB database authentication settings
	* @return CompletableFuture yielding a BrowseSQLServerResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseSQLServerResponse> UserWebDispatcherRequestBrowseMongodbAsync(String TargetID, MongoDBConnection Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseSQLServerResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-browse-mongodb", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseSQLServerResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestBrowseMongodb: Request a list of tables in MongoDB database
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MongoDB database authentication settings
	* @return a BrowseSQLServerResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseSQLServerResponse UserWebDispatcherRequestBrowseMongodb(String TargetID, MongoDBConnection Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRequestBrowseMongodbAsync(TargetID, Credentials).get();
	}

	/**
	* UserWebDispatcherRequestBrowseMssqlAsync: Request a list of tables in MSSQL database
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MSSQL database authentication settings
	* @return CompletableFuture yielding a BrowseSQLServerResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseSQLServerResponse> UserWebDispatcherRequestBrowseMssqlAsync(String TargetID, MSSQLConnection Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseSQLServerResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-browse-mssql", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseSQLServerResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestBrowseMssql: Request a list of tables in MSSQL database
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MSSQL database authentication settings
	* @return a BrowseSQLServerResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseSQLServerResponse UserWebDispatcherRequestBrowseMssql(String TargetID, MSSQLConnection Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRequestBrowseMssqlAsync(TargetID, Credentials).get();
	}

	/**
	* UserWebDispatcherRequestBrowseMysqlAsync: Request a list of tables in MySQL database
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MySQL database authentication settings
	* @return CompletableFuture yielding a BrowseSQLServerResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseSQLServerResponse> UserWebDispatcherRequestBrowseMysqlAsync(String TargetID, MySQLConnection Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseSQLServerResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-browse-mysql", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseSQLServerResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestBrowseMysql: Request a list of tables in MySQL database
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The MySQL database authentication settings
	* @return a BrowseSQLServerResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseSQLServerResponse UserWebDispatcherRequestBrowseMysql(String TargetID, MySQLConnection Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRequestBrowseMysqlAsync(TargetID, Credentials).get();
	}

	/**
	* UserWebDispatcherRequestBrowseVmwareAsync: Request a list of VMware vSphere virtual machines
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The VMWare ESXi connection settings
	* @return CompletableFuture yielding a BrowseVMwareResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseVMwareResponse> UserWebDispatcherRequestBrowseVmwareAsync(String TargetID, VMwareConnection Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseVMwareResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-browse-vmware", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseVMwareResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestBrowseVmware: Request a list of VMware vSphere virtual machines
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The VMWare ESXi connection settings
	* @return a BrowseVMwareResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseVMwareResponse UserWebDispatcherRequestBrowseVmware(String TargetID, VMwareConnection Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRequestBrowseVmwareAsync(TargetID, Credentials).get();
	}

	/**
	* UserWebDispatcherRequestBrowseVssAawAsync: Request a list of installed VSS Writers (Application-Aware Writers) from a
	* live connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return CompletableFuture yielding a BrowseVSSResponse
	*/
	public CompletableFuture<BrowseVSSResponse> UserWebDispatcherRequestBrowseVssAawAsync(String TargetID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		var resultFuture = new CompletableFuture<BrowseVSSResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-browse-vss-aaw", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseVSSResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestBrowseVssAaw: Request a list of installed VSS Writers (Application-Aware Writers) from a live
	* connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @return a BrowseVSSResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BrowseVSSResponse UserWebDispatcherRequestBrowseVssAaw(String TargetID) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRequestBrowseVssAawAsync(TargetID).get();
	}

	/**
	* UserWebDispatcherRequestOffice365AccountsAsync: Request a list of Office365 mailbox accounts
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return CompletableFuture yielding a BrowseOffice365ObjectsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseOffice365ObjectsResponse> UserWebDispatcherRequestOffice365AccountsAsync(String TargetID, Office365Credential Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseOffice365ObjectsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-office365-accounts", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseOffice365ObjectsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestOffice365Accounts: Request a list of Office365 mailbox accounts
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return a BrowseOffice365ObjectsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseOffice365ObjectsResponse UserWebDispatcherRequestOffice365Accounts(String TargetID, Office365Credential Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRequestOffice365AccountsAsync(TargetID, Credentials).get();
	}

	/**
	* UserWebDispatcherRequestOffice365SitesAsync: Request a list of Office365 sites
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return CompletableFuture yielding a BrowseOffice365ObjectsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<BrowseOffice365ObjectsResponse> UserWebDispatcherRequestOffice365SitesAsync(String TargetID, Office365Credential Credentials) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Credentials", CometAPI.getObjectMapper().writeValueAsString(Credentials));
		var resultFuture = new CompletableFuture<BrowseOffice365ObjectsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-office365-sites", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BrowseOffice365ObjectsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestOffice365Sites: Request a list of Office365 sites
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Credentials The Office365 account credential
	* @return a BrowseOffice365ObjectsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public BrowseOffice365ObjectsResponse UserWebDispatcherRequestOffice365Sites(String TargetID, Office365Credential Credentials) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRequestOffice365SitesAsync(TargetID, Credentials).get();
	}

	/**
	* UserWebDispatcherRequestStoredObjectsAsync: Request a list of stored objects inside an existing backup job
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @param SnapshotID The selected backup job snapshot
	* @param TreeID (Optional) Browse objects inside subdirectory of backup snapshot. If it is for VMDK single file
	* restore, it should be the disk image&#39;s subtree ID.
	* @param Options (Optional) Request a list of stored objects in vmdk file
	* @return CompletableFuture yielding a DispatcherStoredObjectsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<DispatcherStoredObjectsResponse> UserWebDispatcherRequestStoredObjectsAsync(String TargetID, String Destination, String SnapshotID, String TreeID, VMDKSnapshotViewOptions Options) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		data.put("SnapshotID", SnapshotID);
		if (TreeID != null) data.put("TreeID",  TreeID);
		if (Options != null) data.put("Options", CometAPI.getObjectMapper().writeValueAsString(Options));
		var resultFuture = new CompletableFuture<DispatcherStoredObjectsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-stored-objects", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherStoredObjectsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestStoredObjects: Request a list of stored objects inside an existing backup job
	* The remote device must have given consent for an MSP to browse their files.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @param SnapshotID The selected backup job snapshot
	* @param TreeID (Optional) Browse objects inside subdirectory of backup snapshot. If it is for VMDK single file
	* restore, it should be the disk image&#39;s subtree ID.
	* @param Options (Optional) Request a list of stored objects in vmdk file
	* @return a DispatcherStoredObjectsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public DispatcherStoredObjectsResponse UserWebDispatcherRequestStoredObjects(String TargetID, String Destination, String SnapshotID, String TreeID, VMDKSnapshotViewOptions Options) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRequestStoredObjectsAsync(TargetID, Destination, SnapshotID, TreeID, Options).get();
	}

	/**
	* UserWebDispatcherRequestVaultSnapshotsAsync: Request a list of Storage Vault snapshots from a live connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @return CompletableFuture yielding a DispatcherVaultSnapshotsResponse
	*/
	public CompletableFuture<DispatcherVaultSnapshotsResponse> UserWebDispatcherRequestVaultSnapshotsAsync(String TargetID, String Destination)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		var resultFuture = new CompletableFuture<DispatcherVaultSnapshotsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-vault-snapshots", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherVaultSnapshotsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestVaultSnapshots: Request a list of Storage Vault snapshots from a live connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @return a DispatcherVaultSnapshotsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public DispatcherVaultSnapshotsResponse UserWebDispatcherRequestVaultSnapshots(String TargetID, String Destination) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRequestVaultSnapshotsAsync(TargetID, Destination).get();
	}

	/**
	* UserWebDispatcherRequestWindiskSnapshotAsync: Request a Disk Image snapshot with the windiskbrowse-style from a live
	* connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @param SnapshotID The Snapshot ID
	* @return CompletableFuture yielding a DispatcherWindiskSnapshotResponse
	*/
	public CompletableFuture<DispatcherWindiskSnapshotResponse> UserWebDispatcherRequestWindiskSnapshotAsync(String TargetID, String Destination, String SnapshotID)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Destination", Destination);
		data.put("SnapshotID", SnapshotID);
		var resultFuture = new CompletableFuture<DispatcherWindiskSnapshotResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/request-windisk-snapshot", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherWindiskSnapshotResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRequestWindiskSnapshot: Request a Disk Image snapshot with the windiskbrowse-style from a live
	* connected device
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Destination The Storage Vault ID
	* @param SnapshotID The Snapshot ID
	* @return a DispatcherWindiskSnapshotResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public DispatcherWindiskSnapshotResponse UserWebDispatcherRequestWindiskSnapshot(String TargetID, String Destination, String SnapshotID) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRequestWindiskSnapshotAsync(TargetID, Destination, SnapshotID).get();
	}

	/**
	* UserWebDispatcherRunBackupAsync: Instruct a live connected device in my account to run a scheduled backup
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param BackupRule The schedule GUID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebDispatcherRunBackupAsync(String TargetID, String BackupRule)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("BackupRule", BackupRule);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/run-backup", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRunBackup: Instruct a live connected device in my account to run a scheduled backup
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param BackupRule The schedule GUID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage UserWebDispatcherRunBackup(String TargetID, String BackupRule) throws ExecutionException, InterruptedException{
		return UserWebDispatcherRunBackupAsync(TargetID, BackupRule).get();
	}

	/**
	* UserWebDispatcherRunBackupCustomAsync: Instruct a live connected device to run a backup
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Source The Protected Item GUID
	* @param Destination The Storage Vault GUID
	* @param Options (Optional) Extra job parameters (&gt;= 19.3.6)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebDispatcherRunBackupCustomAsync(String TargetID, String Source, String Destination, BackupJobAdvancedOptions Options) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Source", Source);
		data.put("Destination", Destination);
		if (Options != null) data.put("Options", CometAPI.getObjectMapper().writeValueAsString(Options));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/run-backup-custom", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRunBackupCustom: Instruct a live connected device to run a backup
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Source The Protected Item GUID
	* @param Destination The Storage Vault GUID
	* @param Options (Optional) Extra job parameters (&gt;= 19.3.6)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage UserWebDispatcherRunBackupCustom(String TargetID, String Source, String Destination, BackupJobAdvancedOptions Options) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRunBackupCustomAsync(TargetID, Source, Destination, Options).get();
	}

	/**
	* UserWebDispatcherRunRestoreAsync: Instruct a live connected device in my account to perform a local restore
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Path The local path to restore to
	* @param Source The Protected Item ID
	* @param Destination The Storage Vault ID
	* @param Snapshot (Optional) If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the
	* selected Protected Item + Storage Vault pair
	* @param Paths (Optional) If present, restore these paths only. Otherwise, restore all data (&gt;= 19.3.0)
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebDispatcherRunRestoreAsync(String TargetID, String Path, String Source, String Destination, String Snapshot, String[] Paths) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Path", Path);
		data.put("Source", Source);
		data.put("Destination", Destination);
		if (Snapshot != null) data.put("Snapshot",  Snapshot);
		if (Paths != null) data.put("Paths", CometAPI.getObjectMapper().writeValueAsString(Paths));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/run-restore", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRunRestore: Instruct a live connected device in my account to perform a local restore
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Path The local path to restore to
	* @param Source The Protected Item ID
	* @param Destination The Storage Vault ID
	* @param Snapshot (Optional) If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the
	* selected Protected Item + Storage Vault pair
	* @param Paths (Optional) If present, restore these paths only. Otherwise, restore all data (&gt;= 19.3.0)
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage UserWebDispatcherRunRestore(String TargetID, String Path, String Source, String Destination, String Snapshot, String[] Paths) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRunRestoreAsync(TargetID, Path, Source, Destination, Snapshot, Paths).get();
	}

	/**
	* UserWebDispatcherRunRestoreCustomAsync: Instruct a live connected device in my account to perform a local restore
	* This command is understood by Comet Backup 18.6.0 and newer.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Source The Protected Item ID
	* @param Destination The Storage Vault ID
	* @param Options Restore targets
	* @param Snapshot (Optional) If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the
	* selected Protected Item + Storage Vault pair
	* @param Paths (Optional) If present, restore these paths only. Otherwise, restore all data (&gt;= 19.3.0)
	* @param KnownFileCount (Optional) The number of files to restore, if known. Supplying this means we don&#39;t need to
	* walk the entire tree just to find the file count and will speed up the restoration process.
	* @param KnownByteCount (Optional) The total size in bytes of files to restore, if known. Supplying this means we
	* don&#39;t need to walk the entire tree just to find the total file size and will speed up the restoration process.
	* @param KnownDirCount (Optional) The number of directories to restore, if known. Supplying this means we don&#39;t
	* need to walk the entire tree just to find the number of directories and will speed up the restoration process.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebDispatcherRunRestoreCustomAsync(String TargetID, String Source, String Destination, RestoreJobAdvancedOptions Options, String Snapshot, String[] Paths, Integer KnownFileCount, Integer KnownByteCount, Integer KnownDirCount) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Source", Source);
		data.put("Destination", Destination);
		data.put("Options", CometAPI.getObjectMapper().writeValueAsString(Options));
		if (Snapshot != null) data.put("Snapshot",  Snapshot);
		if (Paths != null) data.put("Paths", CometAPI.getObjectMapper().writeValueAsString(Paths));
		if (KnownFileCount != null) data.put("KnownFileCount", CometAPI.getObjectMapper().writeValueAsString(KnownFileCount));
		if (KnownByteCount != null) data.put("KnownByteCount", CometAPI.getObjectMapper().writeValueAsString(KnownByteCount));
		if (KnownDirCount != null) data.put("KnownDirCount", CometAPI.getObjectMapper().writeValueAsString(KnownDirCount));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/run-restore-custom", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherRunRestoreCustom: Instruct a live connected device in my account to perform a local restore
	* This command is understood by Comet Backup 18.6.0 and newer.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Source The Protected Item ID
	* @param Destination The Storage Vault ID
	* @param Options Restore targets
	* @param Snapshot (Optional) If present, restore a specific snapshot. Otherwise, restore the latest snapshot for the
	* selected Protected Item + Storage Vault pair
	* @param Paths (Optional) If present, restore these paths only. Otherwise, restore all data (&gt;= 19.3.0)
	* @param KnownFileCount (Optional) The number of files to restore, if known. Supplying this means we don&#39;t need to
	* walk the entire tree just to find the file count and will speed up the restoration process.
	* @param KnownByteCount (Optional) The total size in bytes of files to restore, if known. Supplying this means we
	* don&#39;t need to walk the entire tree just to find the total file size and will speed up the restoration process.
	* @param KnownDirCount (Optional) The number of directories to restore, if known. Supplying this means we don&#39;t
	* need to walk the entire tree just to find the number of directories and will speed up the restoration process.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage UserWebDispatcherRunRestoreCustom(String TargetID, String Source, String Destination, RestoreJobAdvancedOptions Options, String Snapshot, String[] Paths, Integer KnownFileCount, Integer KnownByteCount, Integer KnownDirCount) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherRunRestoreCustomAsync(TargetID, Source, Destination, Options, Snapshot, Paths, KnownFileCount, KnownByteCount, KnownDirCount).get();
	}

	/**
	* UserWebDispatcherSearchSnapshotsAsync: Search storage vault snapshots
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotIDs Snapshots to search
	* @param Filter The search filter
	* @return CompletableFuture yielding a SearchSnapshotsResponse
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<SearchSnapshotsResponse> UserWebDispatcherSearchSnapshotsAsync(String TargetID, String DestinationID, String[] SnapshotIDs, SearchClause Filter) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("DestinationID", DestinationID);
		data.put("SnapshotIDs", CometAPI.getObjectMapper().writeValueAsString(SnapshotIDs));
		data.put("Filter", CometAPI.getObjectMapper().writeValueAsString(Filter));
		var resultFuture = new CompletableFuture<SearchSnapshotsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/search-snapshots", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, SearchSnapshotsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherSearchSnapshots: Search storage vault snapshots
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param DestinationID The Storage Vault GUID
	* @param SnapshotIDs Snapshots to search
	* @param Filter The search filter
	* @return a SearchSnapshotsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public SearchSnapshotsResponse UserWebDispatcherSearchSnapshots(String TargetID, String DestinationID, String[] SnapshotIDs, SearchClause Filter) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherSearchSnapshotsAsync(TargetID, DestinationID, SnapshotIDs, Filter).get();
	}

	/**
	* UserWebDispatcherTestSmbAuthAsync: Test a set of Windows SMB credentials
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Wsa The target credentials to test
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebDispatcherTestSmbAuthAsync(String TargetID, WinSMBAuth Wsa) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		data.put("Wsa", CometAPI.getObjectMapper().writeValueAsString(Wsa));
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/dispatcher/test-smb-auth", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebDispatcherTestSmbAuth: Test a set of Windows SMB credentials
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Wsa The target credentials to test
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage UserWebDispatcherTestSmbAuth(String TargetID, WinSMBAuth Wsa) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebDispatcherTestSmbAuthAsync(TargetID, Wsa).get();
	}

	/**
	* UserWebGetJobLogAsync: Get backup job report log, in plaintext format (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job GUID
	* @return CompletableFuture yielding a byte[]
	*/
	public CompletableFuture<byte[]> UserWebGetJobLogAsync(String JobID)  {
		var data = new HashMap<String,String>();

		data.put("JobID", JobID);
		var resultFuture = new CompletableFuture<byte[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/get-job-log", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, byte[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebGetJobLog: Get backup job report log, in plaintext format (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job GUID
	* @return a byte[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public byte[] UserWebGetJobLog(String JobID) throws ExecutionException, InterruptedException{
		return UserWebGetJobLogAsync(JobID).get();
	}

	/**
	* UserWebGetJobLogEntriesAsync: Get backup job report log (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job GUID
	* @param MinSeverity (Optional) Return only job log entries with equal or higher severity
	* @param MessageContains (Optional) Return only job log entries that contain exact string
	* @return CompletableFuture yielding a JobEntry[]
	*/
	public CompletableFuture<JobEntry[]> UserWebGetJobLogEntriesAsync(String JobID, String MinSeverity, String MessageContains)  {
		var data = new HashMap<String,String>();

		data.put("JobID", JobID);
		if (MinSeverity != null) data.put("MinSeverity",  MinSeverity);
		if (MessageContains != null) data.put("MessageContains",  MessageContains);
		var resultFuture = new CompletableFuture<JobEntry[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/get-job-log-entries", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, JobEntry[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebGetJobLogEntries: Get backup job report log (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job GUID
	* @param MinSeverity (Optional) Return only job log entries with equal or higher severity
	* @param MessageContains (Optional) Return only job log entries that contain exact string
	* @return a JobEntry[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public JobEntry[] UserWebGetJobLogEntries(String JobID, String MinSeverity, String MessageContains) throws ExecutionException, InterruptedException{
		return UserWebGetJobLogEntriesAsync(JobID, MinSeverity, MessageContains).get();
	}

	/**
	* UserWebGetJobPropertiesAsync: Get backup job properties (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job GUID
	* @return CompletableFuture yielding a BackupJobDetail
	*/
	public CompletableFuture<BackupJobDetail> UserWebGetJobPropertiesAsync(String JobID)  {
		var data = new HashMap<String,String>();

		data.put("JobID", JobID);
		var resultFuture = new CompletableFuture<BackupJobDetail>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/get-job-properties", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebGetJobProperties: Get backup job properties (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param JobID Selected job GUID
	* @return a BackupJobDetail
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BackupJobDetail UserWebGetJobProperties(String JobID) throws ExecutionException, InterruptedException{
		return UserWebGetJobPropertiesAsync(JobID).get();
	}

	/**
	* UserWebGetJobsAsync: List all backup jobs (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a BackupJobDetail[]
	*/
	public CompletableFuture<BackupJobDetail[]> UserWebGetJobsAsync()  {
		var resultFuture = new CompletableFuture<BackupJobDetail[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/get-jobs", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebGetJobs: List all backup jobs (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return a BackupJobDetail[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BackupJobDetail[] UserWebGetJobs() throws ExecutionException, InterruptedException{
		return UserWebGetJobsAsync().get();
	}

	/**
	* UserWebGetJobsForCustomSearchAsync: List all backup jobs (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a BackupJobDetail[]
	*/
	public CompletableFuture<BackupJobDetail[]> UserWebGetJobsForCustomSearchAsync()  {
		var resultFuture = new CompletableFuture<BackupJobDetail[]>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/get-jobs-for-custom-search", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, BackupJobDetail[].class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebGetJobsForCustomSearch: List all backup jobs (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return a BackupJobDetail[]
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public BackupJobDetail[] UserWebGetJobsForCustomSearch() throws ExecutionException, InterruptedException{
		return UserWebGetJobsForCustomSearchAsync().get();
	}

	/**
	* UserWebGetUserProfileAndHashAsync: Get user account profile (atomic)
	* (Web interface version)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a GetProfileAndHashResponseMessage
	*/
	public CompletableFuture<GetProfileAndHashResponseMessage> UserWebGetUserProfileAndHashAsync()  {
		var resultFuture = new CompletableFuture<GetProfileAndHashResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/get-user-profile-and-hash", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, GetProfileAndHashResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebGetUserProfileAndHash: Get user account profile (atomic)
	* (Web interface version)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return a GetProfileAndHashResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public GetProfileAndHashResponseMessage UserWebGetUserProfileAndHash() throws ExecutionException, InterruptedException{
		return UserWebGetUserProfileAndHashAsync().get();
	}

	/**
	* UserWebJobCancelAsync: Cancel a running job
	* A request is sent to the live-connected device, asking it to cancel the operation. This may fail if there is no
	* live-connection.
	* Only jobs from Comet 18.3.5 or newer can be cancelled. A job can only be cancelled if it has a non-empty
	* CancellationID field in its properties.
	* If the device is running Comet 21.9.5 or later, this API will wait up to ten seconds for a confirmation from the
	* client.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param JobID Job ID
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebJobCancelAsync(String JobID)  {
		var data = new HashMap<String,String>();

		data.put("JobID", JobID);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/job/cancel", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebJobCancel: Cancel a running job
	* A request is sent to the live-connected device, asking it to cancel the operation. This may fail if there is no
	* live-connection.
	* Only jobs from Comet 18.3.5 or newer can be cancelled. A job can only be cancelled if it has a non-empty
	* CancellationID field in its properties.
	* If the device is running Comet 21.9.5 or later, this API will wait up to ten seconds for a confirmation from the
	* client.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param JobID Job ID
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage UserWebJobCancel(String JobID) throws ExecutionException, InterruptedException{
		return UserWebJobCancelAsync(JobID).get();
	}

	/**
	* UserWebNewsGetAllAsync: Get News entries (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a HashMap&lt;String,NewsEntry&gt;
	*/
	public CompletableFuture<HashMap<String,NewsEntry>> UserWebNewsGetAllAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,NewsEntry>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/news/get-all", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, NewsEntry.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebNewsGetAll: Get News entries (Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return a HashMap&lt;String,NewsEntry&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,NewsEntry> UserWebNewsGetAll() throws ExecutionException, InterruptedException{
		return UserWebNewsGetAllAsync().get();
	}

	/**
	* UserWebRequestFilesystemObjectsAsync: Request a list of filesystem objects from the device
	* The device must have granted the administrator permission to view its filenames.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Path (Optional) Browse objects inside this path. If empty or not present, returns the top-level device paths
	* @return CompletableFuture yielding a DispatcherStoredObjectsResponse
	*/
	public CompletableFuture<DispatcherStoredObjectsResponse> UserWebRequestFilesystemObjectsAsync(String TargetID, String Path)  {
		var data = new HashMap<String,String>();

		data.put("TargetID", TargetID);
		if (Path != null) data.put("Path",  Path);
		var resultFuture = new CompletableFuture<DispatcherStoredObjectsResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/request-filesystem-objects", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, DispatcherStoredObjectsResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebRequestFilesystemObjects: Request a list of filesystem objects from the device
	* The device must have granted the administrator permission to view its filenames.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param TargetID The live connection GUID
	* @param Path (Optional) Browse objects inside this path. If empty or not present, returns the top-level device paths
	* @return a DispatcherStoredObjectsResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public DispatcherStoredObjectsResponse UserWebRequestFilesystemObjects(String TargetID, String Path) throws ExecutionException, InterruptedException{
		return UserWebRequestFilesystemObjectsAsync(TargetID, Path).get();
	}

	/**
	* UserWebRequestStorageVaultAsync: Request a new Storage Vault (Web)
	* This action can be prevented via policy.
	* Prior to Comet 19.8.0, the response type was CometAPIResponseMessage (i.e. no DestinationID field in response).
	* The StorageProvider must exist for the target user account&#39;s organization.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param StorageProvider ID for the storage template destination
	* @param SelfAddress (Optional) The external URL for this server. Used to resolve conflicts
	* @param DeviceID (Optional) The ID of the device to be added as a associated device of the Storage Vault
	* @return CompletableFuture yielding a RequestStorageVaultResponseMessage
	*/
	public CompletableFuture<RequestStorageVaultResponseMessage> UserWebRequestStorageVaultAsync(String StorageProvider, String SelfAddress, String DeviceID)  {
		var data = new HashMap<String,String>();

		data.put("StorageProvider", StorageProvider);
		data.put("SelfAddress", (SelfAddress == null) ? this.serverURL : SelfAddress);
		if (DeviceID != null) data.put("DeviceID",  DeviceID);
		var resultFuture = new CompletableFuture<RequestStorageVaultResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/request-storage-vault", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, RequestStorageVaultResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebRequestStorageVault: Request a new Storage Vault (Web)
	* This action can be prevented via policy.
	* Prior to Comet 19.8.0, the response type was CometAPIResponseMessage (i.e. no DestinationID field in response).
	* The StorageProvider must exist for the target user account&#39;s organization.
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param StorageProvider ID for the storage template destination
	* @param SelfAddress (Optional) The external URL for this server. Used to resolve conflicts
	* @param DeviceID (Optional) The ID of the device to be added as a associated device of the Storage Vault
	* @return a RequestStorageVaultResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public RequestStorageVaultResponseMessage UserWebRequestStorageVault(String StorageProvider, String SelfAddress, String DeviceID) throws ExecutionException, InterruptedException{
		return UserWebRequestStorageVaultAsync(StorageProvider, SelfAddress, DeviceID).get();
	}

	/**
	* UserWebRequestStorageVaultProvidersAsync: Get the available options for Requesting a Storage Vault (User Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a HashMap&lt;String,String&gt;
	*/
	public CompletableFuture<HashMap<String,String>> UserWebRequestStorageVaultProvidersAsync()  {
		var resultFuture = new CompletableFuture<HashMap<String,String>>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/request-storage-vault-providers", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				var type = getObjectMapper().getTypeFactory().constructMapType(HashMap.class, String.class, String.class);
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, type));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebRequestStorageVaultProviders: Get the available options for Requesting a Storage Vault (User Web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return a HashMap&lt;String,String&gt;
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public HashMap<String,String> UserWebRequestStorageVaultProviders() throws ExecutionException, InterruptedException{
		return UserWebRequestStorageVaultProvidersAsync().get();
	}

	/**
	* UserWebSessionRevokeAsync: Revoke a session key (log out)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a CometAPIResponseMessage
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebSessionRevokeAsync()  {
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/session/revoke", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebSessionRevoke: Revoke a session key (log out)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public CometAPIResponseMessage UserWebSessionRevoke() throws ExecutionException, InterruptedException{
		return UserWebSessionRevokeAsync().get();
	}

	/**
	* UserWebSessionStartAsync: Generate a session key (log in)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return CompletableFuture yielding a SessionKeyRegeneratedResponse
	*/
	public CompletableFuture<SessionKeyRegeneratedResponse> UserWebSessionStartAsync()  {
		var resultFuture = new CompletableFuture<SessionKeyRegeneratedResponse>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/session/start", null);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, SessionKeyRegeneratedResponse.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebSessionStart: Generate a session key (log in)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @return a SessionKeyRegeneratedResponse
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	*/
	public SessionKeyRegeneratedResponse UserWebSessionStart() throws ExecutionException, InterruptedException{
		return UserWebSessionStartAsync().get();
	}

	/**
	* UserWebSetProfileHashAsync: Set account profile (atomic, web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param ProfileData Updated account profile
	* @param ProfileHash Previous account profile hash
	* @return CompletableFuture yielding a CometAPIResponseMessage
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CompletableFuture<CometAPIResponseMessage> UserWebSetProfileHashAsync(UserProfileConfig ProfileData, String ProfileHash) throws JsonProcessingException {
		var data = new HashMap<String,String>();

		data.put("ProfileData", CometAPI.getObjectMapper().writeValueAsString(ProfileData));
		data.put("ProfileHash", ProfileHash);
		var resultFuture = new CompletableFuture<CometAPIResponseMessage>(); 
		var responseFuture = request("application/x-www-form-urlencoded", "POST", "/api/v1/user/web/set-profile-hash", data);
		responseFuture.thenAcceptAsync(httpResponse -> {
			try {
				String jsonBody = httpResponse.body();
				resultFuture.complete(CometAPI.getObjectMapper().readValue(jsonBody, CometAPIResponseMessage.class));
			} catch (IOException e) {
				resultFuture.completeExceptionally(e);
			}
		});
		return resultFuture;
	}

	/**
	* UserWebSetProfileHash: Set account profile (atomic, web)
	* 
	* You must supply user authentication credentials to use this API, and the user account must be authorized for web
	* access.
	* This API requires the Auth Role to be enabled.
	* @param ProfileData Updated account profile
	* @param ProfileHash Previous account profile hash
	* @return a CometAPIResponseMessage
	* @throws ExecutionException if the future completed exceptionally
	* @throws InterruptedException if the current thread was interrupted while waiting
	* @throws JsonProcessingException When JSON is malformed (should not happen)
	*/
	public CometAPIResponseMessage UserWebSetProfileHash(UserProfileConfig ProfileData, String ProfileHash) throws ExecutionException, InterruptedException, JsonProcessingException{
		return UserWebSetProfileHashAsync(ProfileData, ProfileHash).get();
	}

}
